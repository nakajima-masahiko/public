<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D„Ç¢„Éê„Çø„ÉºÁµåÊ∏à„Éã„É•„Éº„Çπ„É™„Éº„ÉÄ„Éº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }

        header {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        header h1 {
            font-size: 1.5rem;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .avatar-section {
            flex: 1;
            min-width: 300px;
            max-width: 600px;
        }

        #avatar-container {
            width: 100%;
            height: 400px;
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2e 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        #avatar-container canvas {
            display: block;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 212, 255, 0.3);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            margin-top: 15px;
            color: #00d4ff;
        }

        .news-section {
            flex: 1;
            min-width: 300px;
        }

        .news-list {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .news-list h2 {
            font-size: 1rem;
            color: #00d4ff;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .news-item {
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .news-item:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .news-item.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .news-item .indicator {
            font-size: 0.75rem;
            color: #ffd700;
            margin-bottom: 4px;
        }

        .news-item .title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .news-item .date {
            font-size: 0.8rem;
            color: #888;
        }

        .content-section {
            width: 100%;
            margin-top: 10px;
        }

        .news-content {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            min-height: 150px;
        }

        .news-content h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .news-content .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(0, 212, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
        }

        .stat-item .label {
            font-size: 0.8rem;
            color: #888;
        }

        .stat-item .value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-item .change {
            font-size: 0.9rem;
        }

        .stat-item .change.positive { color: #4caf50; }
        .stat-item .change.negative { color: #f44336; }

        #news-text {
            line-height: 1.8;
            font-size: 1rem;
        }

        #news-text .highlight {
            background: rgba(0, 212, 255, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Text highlight sync styles */
        #news-text .sentence {
            transition: all 0.3s ease;
            padding: 2px 4px;
            border-radius: 4px;
        }

        #news-text .sentence.current {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.4), rgba(0, 150, 255, 0.3));
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        #news-text .sentence.read {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Emotion indicator styles */
        .emotion-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .emotion-indicator .emotion-icon {
            font-size: 1.2rem;
        }

        .emotion-indicator.positive {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .emotion-indicator.negative {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .emotion-indicator.neutral {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .controls {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px 20px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .control-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .voice-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .voice-control label {
            font-size: 0.9rem;
            color: #888;
        }

        .voice-control select {
            background: rgba(0, 0, 0, 0.3);
            color: #e4e4e4;
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.85rem;
            min-width: 150px;
            max-width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .voice-control select:hover {
            border-color: rgba(0, 212, 255, 0.6);
        }

        .voice-control select:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .voice-control select option {
            background: #1a1a2e;
            color: #e4e4e4;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-control label {
            font-size: 0.9rem;
            color: #888;
        }

        .speed-control input[type="range"] {
            width: 100px;
            accent-color: #00d4ff;
        }

        .speed-control span {
            min-width: 40px;
            text-align: center;
        }

        .status {
            font-size: 0.9rem;
            color: #888;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
        }

        .status.speaking {
            color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 10px;
            }

            #avatar-container {
                height: 300px;
            }

            .controls {
                justify-content: center;
            }

            .speed-control {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }

            .voice-control {
                width: 100%;
                justify-content: center;
            }

            .voice-control select {
                max-width: none;
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>3D„Ç¢„Éê„Çø„ÉºÁµåÊ∏à„Éã„É•„Éº„Çπ„É™„Éº„ÉÄ„Éº</h1>
    </header>

    <div class="main-container">
        <div class="avatar-section">
            <div id="avatar-container">
                <div id="loading-overlay">
                    <div class="spinner"></div>
                    <div id="loading-text">„Ç¢„Éê„Çø„Éº„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
                </div>
            </div>
        </div>

        <div class="news-section">
            <div class="news-list">
                <h2>ÁµåÊ∏àÊåáÊ®ô„Éã„É•„Éº„Çπ</h2>
                <div id="news-items"></div>
            </div>
        </div>

        <div class="content-section">
            <div class="news-content">
                <h3 id="content-title">„Éã„É•„Éº„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</h3>
                <div class="stats" id="stats-container"></div>
                <p id="news-text">Â∑¶„ÅÆ„É™„Çπ„Éà„Åã„Çâ„Éã„É•„Éº„Çπ„ÇíÈÅ∏Êäû„Åô„Çã„Å®„ÄÅ„Ç¢„Éê„Çø„Éº„ÅåË™≠„Åø‰∏ä„Åí„Åæ„Åô„ÄÇ</p>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="btn-play" title="ÂÜçÁîü">‚ñ∂</button>
            <button class="control-btn" id="btn-pause" title="‰∏ÄÊôÇÂÅúÊ≠¢" disabled>‚è∏</button>
            <button class="control-btn" id="btn-stop" title="ÂÅúÊ≠¢" disabled>‚èπ</button>
            <span class="status" id="status">ÂæÖÊ©ü‰∏≠</span>
            <div class="emotion-indicator" id="emotion-indicator" style="display: none;">
                <span class="emotion-icon" id="emotion-icon">üòä</span>
                <span id="emotion-text">„Éù„Ç∏„ÉÜ„Ç£„Éñ</span>
            </div>
            <div class="voice-control">
                <label>Èü≥Â£∞:</label>
                <select id="voice-selector">
                    <option value="">Ë™≠„ÅøËæº„Åø‰∏≠...</option>
                </select>
            </div>
            <div class="speed-control">
                <label>ÈÄüÂ∫¶:</label>
                <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
                <span id="speed-value">1.0x</span>
            </div>
        </div>
    </div>

    <!-- Import maps for ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.min.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as VRM from '@pixiv/three-vrm';

        // Economic news data
        const newsData = [
            {
                id: 1,
                indicator: "GDPÊàêÈï∑Áéá",
                title: "Êó•Êú¨„ÅÆÁ¨¨3ÂõõÂçäÊúüGDP„ÄÅ‰∫àÊÉ≥„Çí‰∏äÂõû„ÇãÊàêÈï∑",
                date: "2025Âπ¥1Êúà28Êó•",
                value: "2.1%",
                previousValue: "1.8%",
                change: "+0.3%",
                changeType: "positive",
                content: "ÂÜÖÈñ£Â∫ú„ÅåÁô∫Ë°®„Åó„ÅüÁ¨¨3ÂõõÂçäÊúü„ÅÆÂõΩÂÜÖÁ∑èÁîüÁî£„ÅØ„ÄÅÂâçÊúüÊØîÂπ¥Áéá2.1„Éë„Éº„Çª„É≥„Éà„ÅÆÊàêÈï∑„Å®„Å™„Çä„Åæ„Åó„Åü„ÄÇÂ∏ÇÂ†¥‰∫àÊÉ≥„ÅÆ1.9„Éë„Éº„Çª„É≥„Éà„Çí‰∏äÂõû„Çä„ÄÅÂÄã‰∫∫Ê∂àË≤ª„Å®Ë®≠ÂÇôÊäïË≥á„ÅåÊàêÈï∑„ÇíÁâΩÂºï„Åó„Åæ„Åó„Åü„ÄÇÁâπ„Å´„ÄÅ„Ç§„É≥„Éê„Ç¶„É≥„ÉâÈúÄË¶Å„ÅÆÂõûÂæ©„ÅåÈ°ïËëó„Åß„ÄÅ„Çµ„Éº„Éì„ÇπÊ•≠„Çí‰∏≠ÂøÉ„Å´ÁµåÊ∏àÊ¥ªÂãï„ÅåÊ¥ªÁô∫Âåñ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Ç®„Ç≥„Éé„Éü„Çπ„Éà„ÅØ„ÄÅ„Åì„ÅÆÂÇæÂêë„ÅåÁ¨¨4ÂõõÂçäÊúü„ÇÇÁ∂ö„Åè„Å®‰∫àÊ∏¨„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            },
            {
                id: 2,
                indicator: "Ê∂àË≤ªËÄÖÁâ©‰æ°ÊåáÊï∞",
                title: "1Êúà„ÅÆCPI„ÄÅ2.5%‰∏äÊòá„ÅßÂÆâÂÆöÊé®Áßª",
                date: "2025Âπ¥1Êúà27Êó•",
                value: "2.5%",
                previousValue: "2.4%",
                change: "+0.1%",
                changeType: "positive",
                content: "Á∑èÂãôÁúÅ„ÅåÁô∫Ë°®„Åó„Åü1Êúà„ÅÆÊ∂àË≤ªËÄÖÁâ©‰æ°ÊåáÊï∞„ÅØ„ÄÅÂâçÂπ¥ÂêåÊúàÊØî2.5„Éë„Éº„Çª„É≥„Éà‰∏äÊòá„Åó„Åæ„Åó„Åü„ÄÇ„Ç®„Éç„É´„ÇÆ„Éº‰æ°Ê†º„ÅÆËêΩ„Å°ÁùÄ„Åç„Å´„Çà„Çä„ÄÅ‰∏äÊòáÁéá„ÅØÂÆâÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÁîüÈÆÆÈ£üÂìÅ„ÇíÈô§„Åè„Ç≥„Ç¢CPI„ÇÇ2.3„Éë„Éº„Çª„É≥„Éà„ÅÆ‰∏äÊòá„Å®„Å™„Çä„ÄÅÊó•ÈäÄ„ÅÆÁâ©‰æ°ÁõÆÊ®ô„Åß„ÅÇ„Çã2„Éë„Éº„Çª„É≥„Éà„Çí‰∏äÂõû„ÇãÊ∞¥Ê∫ñ„ÇíÁ∂≠ÊåÅ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂ∏ÇÂ†¥„Åß„ÅØ„ÄÅÈáëËûçÊîøÁ≠ñ„ÅÆÊ≠£Â∏∏Âåñ„Å´Âêë„Åë„ÅüÂãï„Åç„ÅåÊ≥®ÁõÆ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            },
            {
                id: 3,
                indicator: "ÂÆåÂÖ®Â§±Ê•≠Áéá",
                title: "Â§±Ê•≠Áéá2.4%„ÄÅÈõáÁî®Áí∞Â¢É„ÅØÂ†ÖË™ø",
                date: "2025Âπ¥1Êúà26Êó•",
                value: "2.4%",
                previousValue: "2.5%",
                change: "-0.1%",
                changeType: "positive",
                content: "Á∑èÂãôÁúÅ„ÅåÁô∫Ë°®„Åó„Åü12Êúà„ÅÆÂÆåÂÖ®Â§±Ê•≠Áéá„ÅØ2.4„Éë„Éº„Çª„É≥„Éà„Å®„Å™„Çä„ÄÅÂâçÊúà„Åã„Çâ0.1„Éù„Ç§„É≥„ÉàÊîπÂñÑ„Åó„Åæ„Åó„Åü„ÄÇÊúâÂäπÊ±Ç‰∫∫ÂÄçÁéá„ÇÇ1.28ÂÄç„Å®È´òÊ∞¥Ê∫ñ„ÇíÁ∂≠ÊåÅ„Åó„Å¶„Åä„Çä„ÄÅÂä¥ÂÉçÂ∏ÇÂ†¥„ÅØÂºï„ÅçÁ∂ö„ÅçÂ†ÖË™ø„Åß„Åô„ÄÇÁâπ„Å´IT„Éª„Éá„Ç∏„Çø„É´ÂàÜÈáé„Åß„ÅÆ‰∫∫ÊùêÈúÄË¶Å„ÅåÈ´ò„Åæ„Å£„Å¶„Åä„Çä„ÄÅË≥ÉÈáë‰∏äÊòáÂúßÂäõ„ÇÇÁ∂ö„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇÊîøÂ∫ú„ÅØ„ÄÅ„É™„Çπ„Ç≠„É™„É≥„Ç∞ÊîØÊè¥„ÇíÈÄö„Åò„ÅüÂä¥ÂÉçÁßªÂãï„ÅÆ‰øÉÈÄ≤„ÇíÈÄ≤„ÇÅ„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            },
            {
                id: 4,
                indicator: "Êó•ÈäÄÁü≠Ë¶≥",
                title: "Â§ß‰ºÅÊ•≠Ë£ΩÈÄ†Ê•≠„ÅÆÊôØÊ≥ÅÊÑü„ÄÅ3ÊúüÈÄ£Á∂öÊîπÂñÑ",
                date: "2025Âπ¥1Êúà25Êó•",
                value: "+15",
                previousValue: "+12",
                change: "+3„Éù„Ç§„É≥„Éà",
                changeType: "positive",
                content: "Êó•Êú¨ÈäÄË°å„ÅåÁô∫Ë°®„Åó„ÅüÁü≠Ë¶≥„Å´„Çà„Çã„Å®„ÄÅÂ§ß‰ºÅÊ•≠Ë£ΩÈÄ†Ê•≠„ÅÆÊ•≠Ê≥ÅÂà§Êñ≠ÊåáÊï∞„ÅØ„Éó„É©„Çπ15„Å®„Å™„Çä„ÄÅ3ÊúüÈÄ£Á∂ö„ÅßÊîπÂñÑ„Åó„Åæ„Åó„Åü„ÄÇÂçäÂ∞é‰ΩìÈñ¢ÈÄ£„ÇÑËá™ÂãïËªäÁî£Ê•≠„ÅÆÂõûÂæ©„ÅåÂØÑ‰∏é„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ‰∏ÄÊñπ„ÄÅ‰∏≠Â∞è‰ºÅÊ•≠„ÅØ‰∫∫Êâã‰∏çË∂≥„ÇÑ„Ç≥„Çπ„Éà‰∏äÊòá„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å¶„Åä„Çä„ÄÅÂ§ß‰ºÅÊ•≠„Å®„ÅÆÊ†ºÂ∑Æ„ÅåË™≤È°å„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÖàË°å„Åç„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅÊµ∑Â§ñÁµåÊ∏à„ÅÆ‰∏çÁ¢∫ÂÆüÊÄß„Åã„ÇâÊÖéÈáç„Å™Ë¶ãÊñπ„ÇÇÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            },
            {
                id: 5,
                indicator: "Ë≤øÊòìÂèéÊîØ",
                title: "12Êúà„ÅÆË≤øÊòìÂèéÊîØ„ÄÅ2„ÅãÊúà„Å∂„Çä„ÅÆÈªíÂ≠ó",
                date: "2025Âπ¥1Êúà24Êó•",
                value: "+1,250ÂÑÑÂÜÜ",
                previousValue: "-890ÂÑÑÂÜÜ",
                change: "ÈªíÂ≠óËª¢Êèõ",
                changeType: "positive",
                content: "Ë≤°ÂãôÁúÅ„ÅåÁô∫Ë°®„Åó„Åü12Êúà„ÅÆË≤øÊòìÁµ±Ë®à„Å´„Çà„Çã„Å®„ÄÅËº∏Âá∫È°ç„Åã„ÇâËº∏ÂÖ•È°ç„ÇíÂ∑Æ„ÅóÂºï„ÅÑ„ÅüË≤øÊòìÂèéÊîØ„ÅØ1,250ÂÑÑÂÜÜ„ÅÆÈªíÂ≠ó„Å®„Å™„Çä„Åæ„Åó„Åü„ÄÇËá™ÂãïËªä„ÇÑÂçäÂ∞é‰ΩìË£ΩÈÄ†Ë£ÖÁΩÆ„ÅÆËº∏Âá∫„ÅåÂ•ΩË™ø„Åß„ÄÅËº∏Âá∫È°ç„ÅØÂâçÂπ¥ÂêåÊúàÊØî8.5„Éë„Éº„Çª„É≥„ÉàÂ¢óÂä†„Åó„Åæ„Åó„Åü„ÄÇËº∏ÂÖ•È°ç„ÅØ„Ç®„Éç„É´„ÇÆ„Éº‰æ°Ê†º„ÅÆ‰∏ãËêΩ„Å´„Çà„ÇäÊ∏õÂ∞ëÂÇæÂêë„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇÂπ¥Èñì„Åß„ÅØ‰æùÁÑ∂„Å®„Åó„Å¶Ëµ§Â≠ó„Åß„Åô„Åå„ÄÅÊîπÂñÑÂÇæÂêë„ÅåÁ∂ö„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            },
            {
                id: 6,
                indicator: "Ê†™ÂºèÂ∏ÇÂ†¥",
                title: "Êó•ÁµåÂπ≥Âùá„ÄÅ‰∏ñÁïåÁöÑ„Å™ÊôØÊ∞óÊá∏Âøµ„ÅßÂ§ßÂπÖ‰∏ãËêΩ",
                date: "2025Âπ¥1Êúà23Êó•",
                value: "34,500ÂÜÜ",
                previousValue: "36,200ÂÜÜ",
                change: "-4.7%",
                changeType: "negative",
                content: "Êù±‰∫¨Ê†™ÂºèÂ∏ÇÂ†¥„ÅßÊó•ÁµåÂπ≥ÂùáÊ†™‰æ°„ÅåÂ§ßÂπÖ„Å´‰∏ãËêΩ„Åó„Åæ„Åó„Åü„ÄÇÁ±≥ÂõΩ„ÅÆÈáëËûçÊîøÁ≠ñ„Å∏„ÅÆÊá∏Âøµ„Å®‰∏≠ÂõΩÁµåÊ∏à„ÅÆÊ∏õÈÄü„ÅåÈáç„Å™„Çä„ÄÅÊäïË≥áÂÆ∂„ÅÆ„É™„Çπ„ÇØÂõûÈÅøÂßøÂã¢„ÅåÂº∑„Åæ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÁâπ„Å´ÂçäÂ∞é‰ΩìÈñ¢ÈÄ£ÈäòÊüÑ„ÅÆ‰∏ãËêΩ„ÅåÈ°ïËëó„Åß„ÄÅÂ∏ÇÂ†¥ÂÖ®‰Ωì„Å´‰∏çÂÆâ„ÅåÂ∫É„Åå„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Ç¢„Éä„É™„Çπ„Éà„ÅØÂΩìÈù¢„ÅÆË™øÊï¥Â±ÄÈù¢„ÅåÁ∂ö„ÅèÂèØËÉΩÊÄß„ÇíÊåáÊëò„Åó„Å¶„Åä„Çä„ÄÅ‰ªäÂæå„ÅÆÁµåÊ∏àÊåáÊ®ô„Å´Ê≥®ÁõÆ„ÅåÈõÜ„Åæ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            }
        ];

        // App state
        let currentVrm = null;
        let selectedNews = null;
        let isSpeaking = false;
        let isPaused = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let clock = new THREE.Clock();
        let mixer = null;
        let blinkTimer = 0;
        let mouthOpenValue = 0;

        // Text highlight sync state
        let sentences = [];
        let currentSentenceIndex = 0;
        let charIndex = 0;
        let highlightTimer = null;

        // Emotion system state
        let currentEmotion = 'neutral';
        let targetEmotionValues = { happy: 0, sad: 0, angry: 0, surprised: 0 };
        let currentEmotionValues = { happy: 0, sad: 0, angry: 0, surprised: 0 };

        // Startup animation state
        let startupAnimationActive = false;
        let startupAnimationTime = 0;
        let startupAnimationDuration = 1.5; // 1.5 seconds for the animation
        let initialY = 0; // Initial Y position of the model

        // Three.js setup
        const container = document.getElementById('avatar-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const backLight = new THREE.DirectionalLight(0x4488ff, 0.3);
        backLight.position.set(-1, 1, -1);
        scene.add(backLight);

        // Camera position
        camera.position.set(0, 1.3, 1.5);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1;
        controls.maxDistance = 5;
        controls.update();

        // Load VRM model
        const loader = new GLTFLoader();
        loader.register((parser) => new VRM.VRMLoaderPlugin(parser));

        // VRM model URL (using three-vrm sample)
        const vrmUrl = 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';

        loader.load(
            vrmUrl,
            (gltf) => {
                const vrm = gltf.userData.vrm;
                currentVrm = vrm;

                // Start with avatar facing camera (front view)
                vrm.scene.rotation.y = Math.PI;

                // Store initial Y position for jump animation
                initialY = vrm.scene.position.y;

                scene.add(vrm.scene);

                // Hide loading overlay
                document.getElementById('loading-overlay').style.display = 'none';

                // Start the startup animation
                startupAnimationActive = true;
                startupAnimationTime = 0;

                console.log('VRM loaded successfully - starting intro animation');
            },
            (progress) => {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById('loading-text').textContent = `Ë™≠„ÅøËæº„Åø‰∏≠... ${percent}%`;
            },
            (error) => {
                console.error('Error loading VRM:', error);
                document.getElementById('loading-text').textContent = '„É¢„Éá„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
            }
        );

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            if (currentVrm) {
                // Update VRM
                currentVrm.update(deltaTime);

                // Startup animation: jump and half-rotate to face front, then smile
                if (startupAnimationActive) {
                    updateStartupAnimation(deltaTime);
                }

                // Blink animation (skip during startup animation)
                if (!startupAnimationActive) {
                    blinkTimer += deltaTime;
                    if (blinkTimer > 3 + Math.random() * 2) {
                        blink();
                        blinkTimer = 0;
                    }
                }

                // Lip sync when speaking
                if (isSpeaking && !isPaused) {
                    updateLipSync(deltaTime);
                } else {
                    // Gradually close mouth when not speaking
                    mouthOpenValue = Math.max(0, mouthOpenValue - deltaTime * 5);
                    setMouthOpen(mouthOpenValue);
                }

                // Update emotion smoothly
                updateEmotionSmooth(deltaTime);

                // Idle animation - subtle head movement
                const time = clock.elapsedTime;
                if (currentVrm.humanoid) {
                    const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                    if (head) {
                        head.rotation.y = Math.sin(time * 0.5) * 0.05;
                        head.rotation.x = Math.sin(time * 0.3) * 0.02;
                    }
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function blink() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            const blinkDuration = 150;

            currentVrm.expressionManager.setValue('blink', 1);

            setTimeout(() => {
                if (currentVrm && currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('blink', 0);
                }
            }, blinkDuration);
        }

        function updateLipSync(deltaTime) {
            // Simple lip sync - oscillate mouth opening
            const speed = 15;
            const amplitude = 0.5 + Math.random() * 0.3;

            mouthOpenValue = Math.abs(Math.sin(clock.elapsedTime * speed)) * amplitude;
            setMouthOpen(mouthOpenValue);
        }

        function setMouthOpen(value) {
            if (!currentVrm || !currentVrm.expressionManager) return;

            // Try different expression names for mouth
            currentVrm.expressionManager.setValue('aa', value);
            currentVrm.expressionManager.setValue('oh', value * 0.3);
        }

        // Emotion system functions
        function setEmotion(emotion, intensity = 0.7) {
            currentEmotion = emotion;

            // Reset all targets
            targetEmotionValues = { happy: 0, sad: 0, angry: 0, surprised: 0 };

            // Set target based on emotion
            switch (emotion) {
                case 'positive':
                    targetEmotionValues.happy = intensity;
                    break;
                case 'negative':
                    targetEmotionValues.sad = intensity * 0.6;
                    targetEmotionValues.angry = intensity * 0.3;
                    break;
                case 'surprised':
                    targetEmotionValues.surprised = intensity;
                    break;
                case 'neutral':
                default:
                    // All zero - neutral expression
                    break;
            }

            // Update emotion indicator UI
            updateEmotionIndicator(emotion);
        }

        function updateEmotionIndicator(emotion) {
            const indicator = document.getElementById('emotion-indicator');
            const icon = document.getElementById('emotion-icon');
            const text = document.getElementById('emotion-text');

            indicator.style.display = 'flex';
            indicator.className = 'emotion-indicator ' + emotion;

            switch (emotion) {
                case 'positive':
                    icon.textContent = 'üòä';
                    text.textContent = '„Éù„Ç∏„ÉÜ„Ç£„Éñ';
                    break;
                case 'negative':
                    icon.textContent = 'üòü';
                    text.textContent = '„Éç„Ç¨„ÉÜ„Ç£„Éñ';
                    break;
                case 'surprised':
                    icon.textContent = 'üòÆ';
                    text.textContent = 'È©ö„Åç';
                    break;
                case 'neutral':
                default:
                    icon.textContent = 'üòê';
                    text.textContent = '„Éã„É•„Éº„Éà„É©„É´';
                    indicator.className = 'emotion-indicator neutral';
                    break;
            }
        }

        function updateEmotionSmooth(deltaTime) {
            if (!currentVrm || !currentVrm.expressionManager) return;
            if (startupAnimationActive) return; // Skip during startup

            const lerpSpeed = 3; // Smooth transition speed

            // Smoothly interpolate emotion values
            for (const emotion in currentEmotionValues) {
                const target = targetEmotionValues[emotion];
                const current = currentEmotionValues[emotion];
                currentEmotionValues[emotion] = current + (target - current) * deltaTime * lerpSpeed;

                // Apply to VRM
                currentVrm.expressionManager.setValue(emotion, currentEmotionValues[emotion]);
            }
        }

        // Analyze text for emotion keywords and adjust expression
        function analyzeTextEmotion(text) {
            const positiveKeywords = ['‰∏äÊòá', 'ÊàêÈï∑', 'ÊîπÂñÑ', 'Â•ΩË™ø', 'Â¢óÂä†', 'ÈªíÂ≠ó', 'ÂõûÂæ©', '‰∏äÂõû', '„Éó„É©„Çπ'];
            const negativeKeywords = ['‰∏ãËêΩ', 'Ê∏õÂ∞ë', 'ÊÇ™Âåñ', '‰Ωé‰∏ã', 'Ëµ§Â≠ó', 'Êá∏Âøµ', '„Éû„Ç§„Éä„Çπ', '‰∏çÂÆâ', 'Ë™≤È°å'];
            const surpriseKeywords = ['‰∫àÊÉ≥Â§ñ', 'ÊÄ•', 'Â§ßÂπÖ', 'ÈÅéÂéªÊúÄÈ´ò', 'ÈÅéÂéªÊúÄ‰Ωé', 'Âàù„ÇÅ„Å¶'];

            let positiveCount = 0;
            let negativeCount = 0;
            let surpriseCount = 0;

            positiveKeywords.forEach(kw => {
                if (text.includes(kw)) positiveCount++;
            });
            negativeKeywords.forEach(kw => {
                if (text.includes(kw)) negativeCount++;
            });
            surpriseKeywords.forEach(kw => {
                if (text.includes(kw)) surpriseCount++;
            });

            if (surpriseCount > 0) {
                return 'surprised';
            } else if (positiveCount > negativeCount) {
                return 'positive';
            } else if (negativeCount > positiveCount) {
                return 'negative';
            }
            return 'neutral';
        }

        // Text highlight sync functions
        function splitIntoSentences(text) {
            // Split Japanese text by sentence-ending punctuation
            const sentencePattern = /[^„ÄÇÔºÅÔºü]+[„ÄÇÔºÅÔºü]?/g;
            const matches = text.match(sentencePattern) || [text];
            return matches.filter(s => s.trim().length > 0);
        }

        function renderHighlightedText(sentences, currentIndex = -1) {
            const container = document.getElementById('news-text');
            container.innerHTML = sentences.map((sentence, index) => {
                let className = 'sentence';
                if (index < currentIndex) {
                    className += ' read';
                } else if (index === currentIndex) {
                    className += ' current';
                }
                return `<span class="${className}" data-index="${index}">${sentence}</span>`;
            }).join('');
        }

        function updateHighlight(index) {
            currentSentenceIndex = index;
            const sentenceElements = document.querySelectorAll('#news-text .sentence');
            sentenceElements.forEach((el, i) => {
                el.classList.remove('current', 'read');
                if (i < index) {
                    el.classList.add('read');
                } else if (i === index) {
                    el.classList.add('current');
                    // Scroll into view if needed
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                    // Analyze emotion for current sentence and update expression
                    const sentenceText = el.textContent;
                    const emotion = analyzeTextEmotion(sentenceText);
                    setEmotion(emotion);
                }
            });
        }

        function resetHighlight() {
            currentSentenceIndex = 0;
            charIndex = 0;
            const sentenceElements = document.querySelectorAll('#news-text .sentence');
            sentenceElements.forEach(el => {
                el.classList.remove('current', 'read');
            });
            stopHighlightTimer();
        }

        // Timer-based highlight sync (fallback for browsers with poor onboundary support)
        function startHighlightTimer() {
            stopHighlightTimer();

            if (sentences.length === 0) return;

            // Calculate average time per sentence based on speech rate
            const rate = parseFloat(document.getElementById('speed-slider').value);
            const totalChars = sentences.reduce((sum, s) => sum + s.length, 0);
            // Estimate ~7 characters per second at rate 1.0 for Japanese
            const charsPerSecond = 7 * rate;
            const totalDuration = totalChars / charsPerSecond;
            const avgTimePerSentence = (totalDuration / sentences.length) * 1000;

            let timerIndex = 0;
            highlightTimer = setInterval(() => {
                timerIndex++;
                if (timerIndex < sentences.length && isSpeaking && !isPaused) {
                    // Only update if we haven't already moved past this via onboundary
                    if (timerIndex > currentSentenceIndex) {
                        updateHighlight(timerIndex);
                    }
                } else {
                    stopHighlightTimer();
                }
            }, avgTimePerSentence);
        }

        function stopHighlightTimer() {
            if (highlightTimer) {
                clearInterval(highlightTimer);
                highlightTimer = null;
            }
        }

        // Startup animation: jump + half rotation + smile
        function updateStartupAnimation(deltaTime) {
            startupAnimationTime += deltaTime;
            const progress = Math.min(startupAnimationTime / startupAnimationDuration, 1);

            // Easing function for smooth animation
            const easeOutBack = (t) => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            };

            const easeOutBounce = (t) => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            };

            // Jump animation (parabolic curve)
            const jumpHeight = 0.4;
            const jumpProgress = Math.sin(progress * Math.PI); // Parabolic jump
            currentVrm.scene.position.y = initialY + jumpProgress * jumpHeight;

            // Half rotation (PI to 2*PI) - facing front to facing back
            const rotationProgress = easeOutBack(progress);
            currentVrm.scene.rotation.y = Math.PI * (1 + rotationProgress);

            // Gradually build smile near the end of animation
            if (progress > 0.6 && currentVrm.expressionManager) {
                const smileProgress = (progress - 0.6) / 0.4; // 0 to 1 in last 40%
                const smileValue = easeOutBounce(smileProgress) * 0.8;
                currentVrm.expressionManager.setValue('happy', smileValue);
            }

            // Animation complete
            if (progress >= 1) {
                startupAnimationActive = false;
                currentVrm.scene.position.y = initialY;
                currentVrm.scene.rotation.y = 0; // Facing back (away from camera)

                // Set final smile
                if (currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('happy', 0.8);
                }

                console.log('Startup animation complete');

                // Gradually fade out smile after 2 seconds
                setTimeout(() => {
                    fadeOutSmile();
                }, 2000);
            }
        }

        // Fade out smile gradually
        function fadeOutSmile() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            let smileValue = 0.8;
            const fadeInterval = setInterval(() => {
                smileValue -= 0.05;
                if (smileValue <= 0) {
                    smileValue = 0;
                    clearInterval(fadeInterval);
                }
                if (currentVrm && currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('happy', smileValue);
                }
            }, 50);
        }

        animate();

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Render news list
        function renderNewsList() {
            const container = document.getElementById('news-items');
            container.innerHTML = '';

            newsData.forEach(news => {
                const item = document.createElement('div');
                item.className = 'news-item';
                item.dataset.id = news.id;
                item.innerHTML = `
                    <div class="indicator">${news.indicator}</div>
                    <div class="title">${news.title}</div>
                    <div class="date">${news.date}</div>
                `;
                item.addEventListener('click', () => selectNews(news));
                container.appendChild(item);
            });
        }

        function selectNews(news) {
            // Stop current speech if any
            stopSpeech();

            selectedNews = news;

            // Update active state in list
            document.querySelectorAll('.news-item').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.id) === news.id) {
                    item.classList.add('active');
                }
            });

            // Update content display
            document.getElementById('content-title').textContent = news.title;

            const statsContainer = document.getElementById('stats-container');
            statsContainer.innerHTML = `
                <div class="stat-item">
                    <div class="label">ÊåáÊ®ô</div>
                    <div class="value">${news.indicator}</div>
                </div>
                <div class="stat-item">
                    <div class="label">Êï∞ÂÄ§</div>
                    <div class="value">${news.value}</div>
                    <div class="change ${news.changeType}">${news.change}</div>
                </div>
                <div class="stat-item">
                    <div class="label">ÂâçÂõûÂÄ§</div>
                    <div class="value">${news.previousValue}</div>
                </div>
            `;

            // Split content into sentences and render with highlight support
            sentences = splitIntoSentences(news.content);
            renderHighlightedText(sentences);

            // Set initial emotion based on news changeType
            const initialEmotion = news.changeType === 'positive' ? 'positive' :
                                   news.changeType === 'negative' ? 'negative' : 'neutral';
            setEmotion(initialEmotion);

            // Enable play button
            document.getElementById('btn-play').disabled = false;
        }

        // Speech synthesis
        function speak(text) {
            if (!speechSynthesis) {
                alert('„Åä‰Ωø„ÅÑ„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØÈü≥Â£∞ÂêàÊàê„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì');
                return;
            }

            stopSpeech();

            // Reset highlight state
            currentSentenceIndex = 0;
            charIndex = 0;

            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.lang = 'ja-JP';
            currentUtterance.rate = parseFloat(document.getElementById('speed-slider').value);

            // Use selected voice from dropdown
            if (selectedVoice) {
                currentUtterance.voice = selectedVoice;
            }

            currentUtterance.onstart = () => {
                isSpeaking = true;
                isPaused = false;
                updateControlState();
                document.getElementById('status').textContent = 'Ë™≠„Åø‰∏ä„Åí‰∏≠';
                document.getElementById('status').classList.add('speaking');

                // Start highlighting first sentence
                updateHighlight(0);

                // Start timer-based fallback for highlight sync
                // (in case onboundary is not well supported)
                startHighlightTimer();
            };

            // Track progress for highlight sync using boundary events
            currentUtterance.onboundary = (event) => {
                if (event.name === 'sentence' || event.name === 'word') {
                    // Calculate which sentence we're in based on character index
                    const currentCharIndex = event.charIndex;
                    let cumulativeLength = 0;
                    for (let i = 0; i < sentences.length; i++) {
                        cumulativeLength += sentences[i].length;
                        if (currentCharIndex < cumulativeLength) {
                            if (i !== currentSentenceIndex) {
                                updateHighlight(i);
                            }
                            break;
                        }
                    }
                }
            };

            currentUtterance.onend = () => {
                isSpeaking = false;
                isPaused = false;
                updateControlState();
                document.getElementById('status').textContent = 'ÂÆå‰∫Ü';
                document.getElementById('status').classList.remove('speaking');

                // Stop highlight timer
                stopHighlightTimer();

                // Mark all sentences as read
                updateHighlight(sentences.length);

                // Reset emotion to neutral after a short delay
                setTimeout(() => {
                    if (!isSpeaking) {
                        setEmotion('neutral');
                    }
                }, 1500);
            };

            currentUtterance.onerror = (event) => {
                console.error('Speech error:', event);
                isSpeaking = false;
                isPaused = false;
                updateControlState();
                resetHighlight();
            };

            speechSynthesis.speak(currentUtterance);
        }

        function pauseSpeech() {
            if (speechSynthesis && isSpeaking) {
                speechSynthesis.pause();
                isPaused = true;
                document.getElementById('status').textContent = '‰∏ÄÊôÇÂÅúÊ≠¢';
                document.getElementById('status').classList.remove('speaking');
                updateControlState();
            }
        }

        function resumeSpeech() {
            if (speechSynthesis && isPaused) {
                speechSynthesis.resume();
                isPaused = false;
                document.getElementById('status').textContent = 'Ë™≠„Åø‰∏ä„Åí‰∏≠';
                document.getElementById('status').classList.add('speaking');
                updateControlState();
            }
        }

        function stopSpeech() {
            if (speechSynthesis) {
                speechSynthesis.cancel();
                isSpeaking = false;
                isPaused = false;
                document.getElementById('status').textContent = 'ÂæÖÊ©ü‰∏≠';
                document.getElementById('status').classList.remove('speaking');
                updateControlState();

                // Reset highlight
                resetHighlight();

                // Reset emotion to match selected news or neutral
                if (selectedNews) {
                    const emotion = selectedNews.changeType === 'positive' ? 'positive' :
                                    selectedNews.changeType === 'negative' ? 'negative' : 'neutral';
                    setEmotion(emotion);
                } else {
                    setEmotion('neutral');
                }
            }
        }

        function updateControlState() {
            const btnPlay = document.getElementById('btn-play');
            const btnPause = document.getElementById('btn-pause');
            const btnStop = document.getElementById('btn-stop');

            btnPlay.disabled = !selectedNews || (isSpeaking && !isPaused);
            btnPause.disabled = !isSpeaking || isPaused;
            btnStop.disabled = !isSpeaking && !isPaused;

            // Change play button to resume icon when paused
            btnPlay.textContent = isPaused ? '‚ñ∂' : '‚ñ∂';
        }

        // Event listeners
        document.getElementById('btn-play').addEventListener('click', () => {
            if (isPaused) {
                resumeSpeech();
            } else if (selectedNews) {
                speak(selectedNews.content);
            }
        });

        document.getElementById('btn-pause').addEventListener('click', pauseSpeech);
        document.getElementById('btn-stop').addEventListener('click', stopSpeech);

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value).toFixed(1);
            document.getElementById('speed-value').textContent = value + 'x';

            // Update current utterance rate if speaking
            if (currentUtterance) {
                currentUtterance.rate = parseFloat(value);
            }
        });

        // Voice selector state
        let selectedVoice = null;
        let availableVoices = [];

        // Populate voice selector with Japanese voices
        function populateVoiceSelector() {
            const voiceSelector = document.getElementById('voice-selector');
            const voices = speechSynthesis.getVoices();

            // Filter Japanese voices
            availableVoices = voices.filter(voice => voice.lang.includes('ja'));

            // Clear existing options
            voiceSelector.innerHTML = '';

            if (availableVoices.length === 0) {
                // No Japanese voices found, show all voices
                availableVoices = voices;
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Êó•Êú¨Ë™ûÈü≥Â£∞„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì';
                voiceSelector.appendChild(defaultOption);
            }

            // Add Japanese voices to selector
            availableVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;
                // Display voice name and type (local/remote)
                const voiceType = voice.localService ? '„É≠„Éº„Ç´„É´' : '„Ç™„É≥„É©„Ç§„É≥';
                option.textContent = `${voice.name} (${voiceType})`;
                voiceSelector.appendChild(option);
            });

            // Select first voice by default
            if (availableVoices.length > 0) {
                selectedVoice = availableVoices[0];
                voiceSelector.value = '0';
            }

            console.log('Japanese voices loaded:', availableVoices.length);
        }

        // Voice selector change handler
        document.getElementById('voice-selector').addEventListener('change', (e) => {
            const index = parseInt(e.target.value);
            if (!isNaN(index) && availableVoices[index]) {
                selectedVoice = availableVoices[index];
                console.log('Voice selected:', selectedVoice.name);
            }
        });

        // Load voices when available
        speechSynthesis.onvoiceschanged = () => {
            populateVoiceSelector();
        };

        // Try to load voices immediately (some browsers have them ready)
        if (speechSynthesis.getVoices().length > 0) {
            populateVoiceSelector();
        }

        // Initialize
        renderNewsList();

        // Select first news by default
        if (newsData.length > 0) {
            selectNews(newsData[0]);
        }
    </script>
</body>
</html>
