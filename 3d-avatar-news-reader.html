<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dアバター経済ニュースリーダー</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }

        header {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        header h1 {
            font-size: 1.5rem;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .avatar-section {
            flex: 1;
            min-width: 300px;
            max-width: 600px;
        }

        #avatar-container {
            width: 100%;
            height: 400px;
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2e 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        #avatar-container canvas {
            display: block;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 212, 255, 0.3);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            margin-top: 15px;
            color: #00d4ff;
        }

        .news-section {
            flex: 1;
            min-width: 300px;
        }

        .news-list {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .news-list h2 {
            font-size: 1rem;
            color: #00d4ff;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .news-item {
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .news-item:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .news-item.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .news-item .indicator {
            font-size: 0.75rem;
            color: #ffd700;
            margin-bottom: 4px;
        }

        .news-item .title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .news-item .date {
            font-size: 0.8rem;
            color: #888;
        }

        .content-section {
            width: 100%;
            margin-top: 10px;
        }

        .news-content {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            min-height: 150px;
        }

        .news-content h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .news-content .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(0, 212, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
        }

        .stat-item .label {
            font-size: 0.8rem;
            color: #888;
        }

        .stat-item .value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-item .change {
            font-size: 0.9rem;
        }

        .stat-item .change.positive { color: #4caf50; }
        .stat-item .change.negative { color: #f44336; }

        #news-text {
            line-height: 1.8;
            font-size: 1rem;
        }

        #news-text .highlight {
            background: rgba(0, 212, 255, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .controls {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px 20px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .control-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-control label {
            font-size: 0.9rem;
            color: #888;
        }

        .speed-control input[type="range"] {
            width: 100px;
            accent-color: #00d4ff;
        }

        .speed-control span {
            min-width: 40px;
            text-align: center;
        }

        .status {
            font-size: 0.9rem;
            color: #888;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
        }

        .status.speaking {
            color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 10px;
            }

            #avatar-container {
                height: 300px;
            }

            .controls {
                justify-content: center;
            }

            .speed-control {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>3Dアバター経済ニュースリーダー</h1>
    </header>

    <div class="main-container">
        <div class="avatar-section">
            <div id="avatar-container">
                <div id="loading-overlay">
                    <div class="spinner"></div>
                    <div id="loading-text">アバターを読み込み中...</div>
                </div>
            </div>
        </div>

        <div class="news-section">
            <div class="news-list">
                <h2>経済指標ニュース</h2>
                <div id="news-items"></div>
            </div>
        </div>

        <div class="content-section">
            <div class="news-content">
                <h3 id="content-title">ニュースを選択してください</h3>
                <div class="stats" id="stats-container"></div>
                <p id="news-text">左のリストからニュースを選択すると、アバターが読み上げます。</p>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="btn-play" title="再生">▶</button>
            <button class="control-btn" id="btn-pause" title="一時停止" disabled>⏸</button>
            <button class="control-btn" id="btn-stop" title="停止" disabled>⏹</button>
            <span class="status" id="status">待機中</span>
            <div class="speed-control">
                <label>速度:</label>
                <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
                <span id="speed-value">1.0x</span>
            </div>
        </div>
    </div>

    <!-- Import maps for ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.min.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as VRM from '@pixiv/three-vrm';

        // Economic news data
        const newsData = [
            {
                id: 1,
                indicator: "GDP成長率",
                title: "日本の第3四半期GDP、予想を上回る成長",
                date: "2025年1月28日",
                value: "2.1%",
                previousValue: "1.8%",
                change: "+0.3%",
                changeType: "positive",
                content: "内閣府が発表した第3四半期の国内総生産は、前期比年率2.1パーセントの成長となりました。市場予想の1.9パーセントを上回り、個人消費と設備投資が成長を牽引しました。特に、インバウンド需要の回復が顕著で、サービス業を中心に経済活動が活発化しています。エコノミストは、この傾向が第4四半期も続くと予測しています。"
            },
            {
                id: 2,
                indicator: "消費者物価指数",
                title: "1月のCPI、2.5%上昇で安定推移",
                date: "2025年1月27日",
                value: "2.5%",
                previousValue: "2.4%",
                change: "+0.1%",
                changeType: "positive",
                content: "総務省が発表した1月の消費者物価指数は、前年同月比2.5パーセント上昇しました。エネルギー価格の落ち着きにより、上昇率は安定しています。生鮮食品を除くコアCPIも2.3パーセントの上昇となり、日銀の物価目標である2パーセントを上回る水準を維持しています。市場では、金融政策の正常化に向けた動きが注目されています。"
            },
            {
                id: 3,
                indicator: "完全失業率",
                title: "失業率2.4%、雇用環境は堅調",
                date: "2025年1月26日",
                value: "2.4%",
                previousValue: "2.5%",
                change: "-0.1%",
                changeType: "positive",
                content: "総務省が発表した12月の完全失業率は2.4パーセントとなり、前月から0.1ポイント改善しました。有効求人倍率も1.28倍と高水準を維持しており、労働市場は引き続き堅調です。特にIT・デジタル分野での人材需要が高まっており、賃金上昇圧力も続いています。政府は、リスキリング支援を通じた労働移動の促進を進めています。"
            },
            {
                id: 4,
                indicator: "日銀短観",
                title: "大企業製造業の景況感、3期連続改善",
                date: "2025年1月25日",
                value: "+15",
                previousValue: "+12",
                change: "+3ポイント",
                changeType: "positive",
                content: "日本銀行が発表した短観によると、大企業製造業の業況判断指数はプラス15となり、3期連続で改善しました。半導体関連や自動車産業の回復が寄与しています。一方、中小企業は人手不足やコスト上昇の影響を受けており、大企業との格差が課題となっています。先行きについては、海外経済の不確実性から慎重な見方も示されています。"
            },
            {
                id: 5,
                indicator: "貿易収支",
                title: "12月の貿易収支、2か月ぶりの黒字",
                date: "2025年1月24日",
                value: "+1,250億円",
                previousValue: "-890億円",
                change: "黒字転換",
                changeType: "positive",
                content: "財務省が発表した12月の貿易統計によると、輸出額から輸入額を差し引いた貿易収支は1,250億円の黒字となりました。自動車や半導体製造装置の輸出が好調で、輸出額は前年同月比8.5パーセント増加しました。輸入額はエネルギー価格の下落により減少傾向にあります。年間では依然として赤字ですが、改善傾向が続いています。"
            }
        ];

        // App state
        let currentVrm = null;
        let selectedNews = null;
        let isSpeaking = false;
        let isPaused = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let clock = new THREE.Clock();
        let mixer = null;
        let blinkTimer = 0;
        let mouthOpenValue = 0;

        // Startup animation state
        let startupAnimationActive = false;
        let startupAnimationTime = 0;
        let startupAnimationDuration = 1.5; // 1.5 seconds for the animation
        let initialY = 0; // Initial Y position of the model

        // Three.js setup
        const container = document.getElementById('avatar-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const backLight = new THREE.DirectionalLight(0x4488ff, 0.3);
        backLight.position.set(-1, 1, -1);
        scene.add(backLight);

        // Camera position
        camera.position.set(0, 1.3, 1.5);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1;
        controls.maxDistance = 5;
        controls.update();

        // Load VRM model
        const loader = new GLTFLoader();
        loader.register((parser) => new VRM.VRMLoaderPlugin(parser));

        // VRM model URL (using three-vrm sample)
        const vrmUrl = 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';

        loader.load(
            vrmUrl,
            (gltf) => {
                const vrm = gltf.userData.vrm;
                currentVrm = vrm;

                // Start with avatar facing camera (front view)
                vrm.scene.rotation.y = Math.PI;

                // Store initial Y position for jump animation
                initialY = vrm.scene.position.y;

                scene.add(vrm.scene);

                // Hide loading overlay
                document.getElementById('loading-overlay').style.display = 'none';

                // Start the startup animation
                startupAnimationActive = true;
                startupAnimationTime = 0;

                console.log('VRM loaded successfully - starting intro animation');
            },
            (progress) => {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById('loading-text').textContent = `読み込み中... ${percent}%`;
            },
            (error) => {
                console.error('Error loading VRM:', error);
                document.getElementById('loading-text').textContent = 'モデルの読み込みに失敗しました';
            }
        );

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            if (currentVrm) {
                // Update VRM
                currentVrm.update(deltaTime);

                // Startup animation: jump and half-rotate to face front, then smile
                if (startupAnimationActive) {
                    updateStartupAnimation(deltaTime);
                }

                // Blink animation (skip during startup animation)
                if (!startupAnimationActive) {
                    blinkTimer += deltaTime;
                    if (blinkTimer > 3 + Math.random() * 2) {
                        blink();
                        blinkTimer = 0;
                    }
                }

                // Lip sync when speaking
                if (isSpeaking && !isPaused) {
                    updateLipSync(deltaTime);
                } else {
                    // Gradually close mouth when not speaking
                    mouthOpenValue = Math.max(0, mouthOpenValue - deltaTime * 5);
                    setMouthOpen(mouthOpenValue);
                }

                // Idle animation - subtle head movement
                const time = clock.elapsedTime;
                if (currentVrm.humanoid) {
                    const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                    if (head) {
                        head.rotation.y = Math.sin(time * 0.5) * 0.05;
                        head.rotation.x = Math.sin(time * 0.3) * 0.02;
                    }
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function blink() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            const blinkDuration = 150;

            currentVrm.expressionManager.setValue('blink', 1);

            setTimeout(() => {
                if (currentVrm && currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('blink', 0);
                }
            }, blinkDuration);
        }

        function updateLipSync(deltaTime) {
            // Simple lip sync - oscillate mouth opening
            const speed = 15;
            const amplitude = 0.5 + Math.random() * 0.3;

            mouthOpenValue = Math.abs(Math.sin(clock.elapsedTime * speed)) * amplitude;
            setMouthOpen(mouthOpenValue);
        }

        function setMouthOpen(value) {
            if (!currentVrm || !currentVrm.expressionManager) return;

            // Try different expression names for mouth
            currentVrm.expressionManager.setValue('aa', value);
            currentVrm.expressionManager.setValue('oh', value * 0.3);
        }

        // Startup animation: jump + half rotation + smile
        function updateStartupAnimation(deltaTime) {
            startupAnimationTime += deltaTime;
            const progress = Math.min(startupAnimationTime / startupAnimationDuration, 1);

            // Easing function for smooth animation
            const easeOutBack = (t) => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            };

            const easeOutBounce = (t) => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            };

            // Jump animation (parabolic curve)
            const jumpHeight = 0.4;
            const jumpProgress = Math.sin(progress * Math.PI); // Parabolic jump
            currentVrm.scene.position.y = initialY + jumpProgress * jumpHeight;

            // Half rotation (PI to 2*PI) - facing front to facing back
            const rotationProgress = easeOutBack(progress);
            currentVrm.scene.rotation.y = Math.PI * (1 + rotationProgress);

            // Gradually build smile near the end of animation
            if (progress > 0.6 && currentVrm.expressionManager) {
                const smileProgress = (progress - 0.6) / 0.4; // 0 to 1 in last 40%
                const smileValue = easeOutBounce(smileProgress) * 0.8;
                currentVrm.expressionManager.setValue('happy', smileValue);
            }

            // Animation complete
            if (progress >= 1) {
                startupAnimationActive = false;
                currentVrm.scene.position.y = initialY;
                currentVrm.scene.rotation.y = 0; // Facing back (away from camera)

                // Set final smile
                if (currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('happy', 0.8);
                }

                console.log('Startup animation complete');

                // Gradually fade out smile after 2 seconds
                setTimeout(() => {
                    fadeOutSmile();
                }, 2000);
            }
        }

        // Fade out smile gradually
        function fadeOutSmile() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            let smileValue = 0.8;
            const fadeInterval = setInterval(() => {
                smileValue -= 0.05;
                if (smileValue <= 0) {
                    smileValue = 0;
                    clearInterval(fadeInterval);
                }
                if (currentVrm && currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('happy', smileValue);
                }
            }, 50);
        }

        animate();

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Render news list
        function renderNewsList() {
            const container = document.getElementById('news-items');
            container.innerHTML = '';

            newsData.forEach(news => {
                const item = document.createElement('div');
                item.className = 'news-item';
                item.dataset.id = news.id;
                item.innerHTML = `
                    <div class="indicator">${news.indicator}</div>
                    <div class="title">${news.title}</div>
                    <div class="date">${news.date}</div>
                `;
                item.addEventListener('click', () => selectNews(news));
                container.appendChild(item);
            });
        }

        function selectNews(news) {
            // Stop current speech if any
            stopSpeech();

            selectedNews = news;

            // Update active state in list
            document.querySelectorAll('.news-item').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.id) === news.id) {
                    item.classList.add('active');
                }
            });

            // Update content display
            document.getElementById('content-title').textContent = news.title;

            const statsContainer = document.getElementById('stats-container');
            statsContainer.innerHTML = `
                <div class="stat-item">
                    <div class="label">指標</div>
                    <div class="value">${news.indicator}</div>
                </div>
                <div class="stat-item">
                    <div class="label">数値</div>
                    <div class="value">${news.value}</div>
                    <div class="change ${news.changeType}">${news.change}</div>
                </div>
                <div class="stat-item">
                    <div class="label">前回値</div>
                    <div class="value">${news.previousValue}</div>
                </div>
            `;

            document.getElementById('news-text').textContent = news.content;

            // Enable play button
            document.getElementById('btn-play').disabled = false;
        }

        // Speech synthesis
        function speak(text) {
            if (!speechSynthesis) {
                alert('お使いのブラウザは音声合成に対応していません');
                return;
            }

            stopSpeech();

            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.lang = 'ja-JP';
            currentUtterance.rate = parseFloat(document.getElementById('speed-slider').value);

            // Try to find Japanese voice
            const voices = speechSynthesis.getVoices();
            const japaneseVoice = voices.find(voice => voice.lang.includes('ja'));
            if (japaneseVoice) {
                currentUtterance.voice = japaneseVoice;
            }

            currentUtterance.onstart = () => {
                isSpeaking = true;
                isPaused = false;
                updateControlState();
                document.getElementById('status').textContent = '読み上げ中';
                document.getElementById('status').classList.add('speaking');
            };

            currentUtterance.onend = () => {
                isSpeaking = false;
                isPaused = false;
                updateControlState();
                document.getElementById('status').textContent = '完了';
                document.getElementById('status').classList.remove('speaking');
            };

            currentUtterance.onerror = (event) => {
                console.error('Speech error:', event);
                isSpeaking = false;
                isPaused = false;
                updateControlState();
            };

            speechSynthesis.speak(currentUtterance);
        }

        function pauseSpeech() {
            if (speechSynthesis && isSpeaking) {
                speechSynthesis.pause();
                isPaused = true;
                document.getElementById('status').textContent = '一時停止';
                document.getElementById('status').classList.remove('speaking');
                updateControlState();
            }
        }

        function resumeSpeech() {
            if (speechSynthesis && isPaused) {
                speechSynthesis.resume();
                isPaused = false;
                document.getElementById('status').textContent = '読み上げ中';
                document.getElementById('status').classList.add('speaking');
                updateControlState();
            }
        }

        function stopSpeech() {
            if (speechSynthesis) {
                speechSynthesis.cancel();
                isSpeaking = false;
                isPaused = false;
                document.getElementById('status').textContent = '待機中';
                document.getElementById('status').classList.remove('speaking');
                updateControlState();
            }
        }

        function updateControlState() {
            const btnPlay = document.getElementById('btn-play');
            const btnPause = document.getElementById('btn-pause');
            const btnStop = document.getElementById('btn-stop');

            btnPlay.disabled = !selectedNews || (isSpeaking && !isPaused);
            btnPause.disabled = !isSpeaking || isPaused;
            btnStop.disabled = !isSpeaking && !isPaused;

            // Change play button to resume icon when paused
            btnPlay.textContent = isPaused ? '▶' : '▶';
        }

        // Event listeners
        document.getElementById('btn-play').addEventListener('click', () => {
            if (isPaused) {
                resumeSpeech();
            } else if (selectedNews) {
                speak(selectedNews.content);
            }
        });

        document.getElementById('btn-pause').addEventListener('click', pauseSpeech);
        document.getElementById('btn-stop').addEventListener('click', stopSpeech);

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value).toFixed(1);
            document.getElementById('speed-value').textContent = value + 'x';

            // Update current utterance rate if speaking
            if (currentUtterance) {
                currentUtterance.rate = parseFloat(value);
            }
        });

        // Load voices when available
        speechSynthesis.onvoiceschanged = () => {
            console.log('Voices loaded:', speechSynthesis.getVoices().length);
        };

        // Initialize
        renderNewsList();

        // Select first news by default
        if (newsData.length > 0) {
            selectNews(newsData[0]);
        }
    </script>
</body>
</html>
