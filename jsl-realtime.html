<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSL ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èªè­˜ãƒ‡ãƒ¢</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: #1e293b;
      --text: #f8fafc;
      --accent: #38bdf8;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    body {
      margin: 0;
      font-family: "Noto Sans JP", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
    }
    .tab-shell {
      display: grid;
      gap: 16px;
    }
    .tabs {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tab-button {
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 8px 16px;
      background: #334155;
      color: inherit;
      cursor: pointer;
      font-weight: 600;
    }
    .tab-button.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.2);
    }
    .tab-panel {
      display: none;
    }
    .tab-panel.active {
      display: block;
    }
    .app {
      display: grid;
      grid-template-columns: minmax(300px, 1fr) 320px;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr;
      }
    }
    header {
      grid-column: 1 / -1;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }
    h2 {
      margin: 0 0 12px;
      font-size: 1.3rem;
    }
    h3 {
      margin: 16px 0 8px;
      font-size: 1.1rem;
    }
    p {
      margin: 0;
      opacity: 0.8;
    }
    .video-wrap {
      position: relative;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      min-height: 320px;
    }
    video, canvas {
      width: 100%;
      height: 100%;
      display: block;
      transform: scaleX(-1);
    }
    canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .control {
      display: grid;
      gap: 8px;
    }
    label {
      font-weight: 600;
    }
    input[type="range"] {
      width: 100%;
    }
    input[type="text"], input[type="search"] {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #475569;
      background: rgba(15, 23, 42, 0.4);
      color: inherit;
      font-size: 1rem;
    }
    input[type="text"]:focus, input[type="search"]:focus {
      outline: none;
      border-color: var(--accent);
    }
    select {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #475569;
      background: #334155;
      color: inherit;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .toggle {
      display: inline-flex;
      gap: 8px;
    }
    .toggle button {
      flex: 1;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 8px 12px;
      background: #334155;
      color: inherit;
      cursor: pointer;
    }
    .toggle button.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.2);
    }
    .result {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent);
    }
    .history {
      max-height: 220px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
    }
    .history-item {
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      font-size: 0.95rem;
    }
    .small {
      font-size: 0.85rem;
      opacity: 0.8;
    }
    .status {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    .btn {
      border-radius: 8px;
      border: none;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.2s;
    }
    .btn-primary {
      background: var(--accent);
      color: #0f172a;
    }
    .btn-primary:hover {
      background: #7dd3fc;
    }
    .btn-primary:disabled {
      background: #475569;
      color: #94a3b8;
      cursor: not-allowed;
    }
    .btn-secondary {
      background: #475569;
      color: inherit;
    }
    .btn-secondary:hover {
      background: #64748b;
    }
    .btn-secondary:disabled {
      background: #334155;
      color: #64748b;
      cursor: not-allowed;
    }
    .btn-success {
      background: var(--success);
      color: #0f172a;
    }
    .btn-success:hover {
      background: #4ade80;
    }
    .btn-danger {
      background: var(--danger);
      color: white;
    }
    .btn-danger:hover {
      background: #f87171;
    }
    .btn-danger:disabled {
      background: #7f1d1d;
      color: #fca5a5;
      cursor: not-allowed;
    }
    .btn-row {
      display: flex;
      gap: 8px;
    }
    .btn-row .btn {
      flex: 1;
    }
    .info-panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 20px;
      display: grid;
      gap: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-panel ol {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 8px;
    }
    .info-panel ul {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 6px;
    }
    .info-panel a {
      color: var(--accent);
    }

    /* è¨˜éŒ²ã‚¿ãƒ–ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .record-app {
      display: grid;
      grid-template-columns: minmax(300px, 1fr) 360px;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .record-app {
        grid-template-columns: 1fr;
      }
    }
    .progress-steps {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
    }
    .step {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
    }
    .step-indicator {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
      background: #475569;
    }
    .step.active .step-indicator {
      background: var(--accent);
      color: #0f172a;
    }
    .step.completed .step-indicator {
      background: var(--success);
      color: #0f172a;
    }
    .step-arrow {
      color: #64748b;
    }
    .record-status {
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      font-weight: 600;
    }
    .record-status.idle {
      background: rgba(71, 85, 105, 0.4);
    }
    .record-status.recording {
      background: rgba(239, 68, 68, 0.3);
      color: #fca5a5;
      animation: pulse 1.5s infinite;
    }
    .record-status.waiting {
      background: rgba(245, 158, 11, 0.3);
      color: #fcd34d;
    }
    .record-status.labeling {
      background: rgba(34, 197, 94, 0.3);
      color: #86efac;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .voice-input-area {
      display: grid;
      gap: 12px;
      padding: 16px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
    }
    .voice-input-area.hidden {
      display: none;
    }

    /* ä¸€è¦§ã‚¿ãƒ–ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .list-app {
      max-width: 900px;
    }
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
    }
    .list-controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .word-table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      overflow: hidden;
    }
    .word-table th, .word-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #334155;
    }
    .word-table th {
      background: #334155;
      font-weight: 600;
    }
    .word-table tr:last-child td {
      border-bottom: none;
    }
    .word-table tr:hover td {
      background: rgba(56, 189, 248, 0.1);
    }
    .word-table input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .bulk-actions {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 12px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      margin-top: 16px;
    }
    .data-management {
      margin-top: 24px;
      padding: 20px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 12px;
    }
    .data-management h3 {
      margin-top: 0;
    }
    .data-section {
      display: grid;
      gap: 12px;
      margin-top: 12px;
    }
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #94a3b8;
    }
    input[type="file"] {
      display: none;
    }
  </style>
</head>
<body>
  <div class="tab-shell">
    <div class="tabs" role="tablist" aria-label="ãƒ‡ãƒ¢åˆ‡ã‚Šæ›¿ãˆ">
      <button class="tab-button active" role="tab" aria-selected="true" aria-controls="tab-recognize" id="tabButtonRecognize" type="button">èªè­˜</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-record" id="tabButtonRecord" type="button">è¨˜éŒ²</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-list" id="tabButtonList" type="button">ä¸€è¦§</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-manual" id="tabButtonManual" type="button">ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-spec" id="tabButtonSpec" type="button">ä»•æ§˜</button>
    </div>

    <!-- èªè­˜ã‚¿ãƒ– -->
    <section id="tab-recognize" class="tab-panel active" role="tabpanel" aria-labelledby="tabButtonRecognize">
      <div class="app">
        <header>
          <h1>æ—¥æœ¬æ‰‹è©± (JSL) ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èªè­˜ ãƒ‡ãƒ¢</h1>
          <p>MediaPipe Hands ã¨ TensorFlow.js (KNN) ã‚’ä½¿ã£ãŸå®Œå…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ãƒ™ãƒ¼ã‚¹å®Ÿè£…ã§ã™ã€‚</p>
        </header>

        <div class="video-wrap">
          <video id="video" autoplay playsinline aria-label="ã‚«ãƒ¡ãƒ©æ˜ åƒ"></video>
          <canvas id="overlay"></canvas>
        </div>

        <aside class="panel">
          <div class="control">
            <label for="threshold">èªè­˜ä¿¡é ¼åº¦ã—ãã„å€¤: <span id="thresholdValue">0.75</span></label>
            <input id="threshold" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div class="control">
            <label>ãƒ¢ãƒ‡ãƒ«ç¨®é¡</label>
            <div class="toggle">
              <button id="modelLite" class="active" type="button">é«˜é€Ÿ (Lite)</button>
              <button id="modelFull" type="button">é«˜ç²¾åº¦ (Full)</button>
            </div>
            <div class="small">â€» ãƒ¢ãƒ‡ãƒ«åˆ‡æ›¿å¾Œã¯å†èª­ã¿è¾¼ã¿ãŒå¿…è¦ã§ã™ã€‚</div>
          </div>

          <div class="control">
            <label>èªè­˜çµæœ</label>
            <div id="result" class="result">--</div>
            <div id="score" class="small">score: --</div>
          </div>

          <div class="control">
            <label>å±¥æ­´</label>
            <div id="history" class="history"></div>
          </div>

          <div id="statusRecognize" class="status">åˆæœŸåŒ–ä¸­...</div>
        </aside>
      </div>
    </section>

    <!-- è¨˜éŒ²ã‚¿ãƒ– -->
    <section id="tab-record" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonRecord">
      <div class="record-app">
        <header>
          <h1>æ‰‹è©±å˜èªã®è¨˜éŒ²</h1>
          <p>æ‰‹è©±ã‚’2å›å®Ÿæ¼”ã—ã€éŸ³å£°ã§å˜èªåã‚’ç™»éŒ²ã—ã¾ã™ã€‚</p>
        </header>

        <div class="video-wrap">
          <video id="videoRecord" autoplay playsinline aria-label="ã‚«ãƒ¡ãƒ©æ˜ åƒ"></video>
          <canvas id="overlayRecord"></canvas>
        </div>

        <aside class="panel">
          <div class="control">
            <label>é€²æ—</label>
            <div class="progress-steps">
              <div class="step active" id="step1">
                <span class="step-indicator">1</span>
                <span>1å›ç›®</span>
              </div>
              <span class="step-arrow">â†’</span>
              <div class="step" id="step2">
                <span class="step-indicator">2</span>
                <span>2å›ç›®</span>
              </div>
              <span class="step-arrow">â†’</span>
              <div class="step" id="step3">
                <span class="step-indicator">3</span>
                <span>ç™»éŒ²</span>
              </div>
            </div>
          </div>

          <div class="control">
            <label>è¨˜éŒ²çŠ¶æ…‹</label>
            <div id="recordStatus" class="record-status idle">å¾…æ©Ÿä¸­ - ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„</div>
          </div>

          <div class="control">
            <label>è¨˜éŒ²ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</label>
            <div class="btn-row">
              <button id="btnStartRecord" class="btn btn-success" type="button">é–‹å§‹</button>
              <button id="btnStopRecord" class="btn btn-danger" type="button" disabled>çµ‚äº†</button>
            </div>
          </div>

          <div id="voiceInputArea" class="voice-input-area hidden">
            <label>å˜èªåã‚’å…¥åŠ›</label>
            <input id="labelInputRecord" type="text" placeholder="éŸ³å£°å…¥åŠ›ã¾ãŸã¯æ‰‹å‹•ã§å…¥åŠ›" />
            <div class="btn-row">
              <button id="btnVoiceInput" class="btn btn-secondary" type="button">ğŸ¤ éŸ³å£°å…¥åŠ›</button>
              <button id="btnRegister" class="btn btn-primary" type="button">ç™»éŒ²ã™ã‚‹</button>
            </div>
            <div class="small">â€» éŸ³å£°å…¥åŠ›å¾Œã€ãƒ†ã‚­ã‚¹ãƒˆã¯ç·¨é›†ã§ãã¾ã™</div>
          </div>

          <div class="control">
            <button id="btnResetRecord" class="btn btn-secondary" type="button">ãƒªã‚»ãƒƒãƒˆ</button>
          </div>

          <div id="statusRecord" class="status">æº–å‚™å®Œäº†</div>
        </aside>
      </div>
    </section>

    <!-- ä¸€è¦§ã‚¿ãƒ– -->
    <section id="tab-list" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonList">
      <div class="list-app">
        <header>
          <h1>ç™»éŒ²æ¸ˆã¿å˜èªä¸€è¦§</h1>
        </header>

        <div class="panel">
          <div class="list-header">
            <div>
              <span id="wordCount">ç™»éŒ²æ•°: 0ä»¶</span>
            </div>
            <div class="list-controls">
              <select id="sortSelect">
                <option value="name-asc">åå‰é † (Aâ†’Z)</option>
                <option value="name-desc">åå‰é † (Zâ†’A)</option>
                <option value="count-desc">ã‚µãƒ³ãƒ—ãƒ«æ•° (å¤šã„é †)</option>
                <option value="count-asc">ã‚µãƒ³ãƒ—ãƒ«æ•° (å°‘ãªã„é †)</option>
                <option value="date-desc">ç™»éŒ²æ—¥æ™‚ (æ–°ã—ã„é †)</option>
                <option value="date-asc">ç™»éŒ²æ—¥æ™‚ (å¤ã„é †)</option>
              </select>
              <input id="searchInput" type="search" placeholder="æ¤œç´¢..." />
            </div>
          </div>

          <div id="wordListContainer">
            <table class="word-table">
              <thead>
                <tr>
                  <th style="width: 40px;"><input type="checkbox" id="selectAll" /></th>
                  <th>å˜èªå</th>
                  <th style="width: 100px;">ã‚µãƒ³ãƒ—ãƒ«æ•°</th>
                  <th style="width: 160px;">ç™»éŒ²æ—¥æ™‚</th>
                  <th style="width: 80px;">æ“ä½œ</th>
                </tr>
              </thead>
              <tbody id="wordTableBody">
              </tbody>
            </table>
            <div id="emptyState" class="empty-state hidden">
              ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å˜èªã¯ã‚ã‚Šã¾ã›ã‚“
            </div>
          </div>

          <div class="bulk-actions">
            <label>
              <input type="checkbox" id="selectAllBulk" /> å…¨é¸æŠ
            </label>
            <button id="btnDeleteSelected" class="btn btn-danger" type="button" disabled>é¸æŠé …ç›®ã‚’å‰Šé™¤</button>
          </div>

          <div class="data-management">
            <h3>ãƒ‡ãƒ¼ã‚¿ç®¡ç†</h3>
            <div class="data-section">
              <label>ãƒ–ãƒ©ã‚¦ã‚¶ä¿å­˜</label>
              <div class="btn-row">
                <button id="saveToStorage" class="btn btn-primary" type="button">ä¿å­˜ (Storage)</button>
                <button id="loadFromStorage" class="btn btn-secondary" type="button">å¾©å…ƒ (Storage)</button>
              </div>
            </div>
            <div class="data-section">
              <label>ãƒ•ã‚¡ã‚¤ãƒ«å…¥å‡ºåŠ›</label>
              <div class="btn-row">
                <button id="exportFile" class="btn btn-secondary" type="button">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button id="importFileBtn" class="btn btn-secondary" type="button">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                <input id="importFile" type="file" accept=".json" />
              </div>
            </div>
            <div class="data-section">
              <button id="clearData" class="btn btn-danger" type="button">å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤</button>
            </div>
            <div id="statusList" class="status" style="margin-top: 12px;"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚¿ãƒ– -->
    <section id="tab-manual" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonManual">
      <div class="info-panel">
        <h2>ä½¿ã„æ–¹</h2>

        <h3>èªè­˜ã‚¿ãƒ–</h3>
        <ol>
          <li>ã€Œèªè­˜ã€ã‚¿ãƒ–ã§ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ã¾ã™ã€‚</li>
          <li>æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã€ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ï¼ˆç‚¹ã¨æ¥ç¶šç·šï¼‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚</li>
          <li>èªè­˜çµæœã®ã—ãã„å€¤ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§èª¿æ•´ã—ã¾ã™ã€‚</li>
          <li>å±¥æ­´ã‚„ã‚¹ã‚³ã‚¢ã‚’ç¢ºèªã—ãªãŒã‚‰å‹•ä½œã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚</li>
        </ol>

        <h3>è¨˜éŒ²ã‚¿ãƒ–</h3>
        <ol>
          <li>ã€Œè¨˜éŒ²ã€ã‚¿ãƒ–ã«ç§»å‹•ã—ã¾ã™ã€‚</li>
          <li>ã€Œé–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã€è¨˜éŒ²ã—ãŸã„æ‰‹è©±ã‚’å®Ÿæ¼”ã—ã¾ã™ã€‚</li>
          <li>ã€Œçµ‚äº†ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦1å›ç›®ã®è¨˜éŒ²ã‚’å®Œäº†ã—ã¾ã™ã€‚</li>
          <li>ã‚‚ã†ä¸€åº¦ã€Œé–‹å§‹ã€â†’ æ‰‹è©±å®Ÿæ¼” â†’ã€Œçµ‚äº†ã€ã§2å›ç›®ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚</li>
          <li>éŸ³å£°å…¥åŠ›ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã€ãã®æ‰‹è©±ã®æ„å‘³ã‚’ç™ºè©±ã—ã¾ã™ã€‚</li>
          <li>ãƒ†ã‚­ã‚¹ãƒˆãŒæ­£ã—ããªã„å ´åˆã¯æ‰‹å‹•ã§ä¿®æ­£ã—ã¾ã™ã€‚</li>
          <li>ã€Œç™»éŒ²ã™ã‚‹ã€ãƒœã‚¿ãƒ³ã§æ‰‹è©±å˜èªã‚’ä¿å­˜ã—ã¾ã™ã€‚</li>
        </ol>

        <h3>ä¸€è¦§ã‚¿ãƒ–</h3>
        <h4>å˜èªã®ç¢ºèªãƒ»ç®¡ç†</h4>
        <ol>
          <li>ã€Œä¸€è¦§ã€ã‚¿ãƒ–ã«ç§»å‹•ã—ã¾ã™ã€‚</li>
          <li>ç™»éŒ²æ¸ˆã¿ã®æ‰‹è©±å˜èªãŒä¸€è¦§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
          <li>ã‚½ãƒ¼ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã§ä¸¦ã³æ›¿ãˆãŒã§ãã¾ã™ã€‚</li>
          <li>æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ã§å˜èªã‚’çµã‚Šè¾¼ã‚ã¾ã™ã€‚</li>
        </ol>

        <h4>å˜èªã®å‰Šé™¤</h4>
        <ol>
          <li>å‰Šé™¤ã—ãŸã„å˜èªã®è¡Œã®ã€Œå‰Šé™¤ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚</li>
          <li>ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€ŒOKã€ã‚’é¸æŠã—ã¾ã™ã€‚</li>
          <li>è¤‡æ•°å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã§é¸æŠå¾Œã€Œé¸æŠé …ç›®ã‚’å‰Šé™¤ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚</li>
        </ol>

        <h4>ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã¨èª­è¾¼</h4>
        <ul>
          <li><strong>ä¿å­˜ (Storage)</strong>: å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã—ã¾ã™ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ã‚‚ä¿æŒï¼‰ã€‚</li>
          <li><strong>å¾©å…ƒ (Storage)</strong>: ä¿å­˜ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚</li>
          <li><strong>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</strong>: JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</li>
          <li><strong>ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</strong>: ä»–ã®ç’°å¢ƒã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚</li>
        </ul>

      </div>
    </section>

    <!-- ä»•æ§˜ã‚¿ãƒ– -->
    <section id="tab-spec" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonSpec">
      <div class="info-panel">
        <h2>ä»•æ§˜ãƒ»ä½¿ç”¨æŠ€è¡“</h2>
        <ul>
          <li>MediaPipe Hands ã«ã‚ˆã‚‹æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¤œå‡ºï¼ˆ21ç‚¹ï¼‰ã€‚</li>
          <li>TensorFlow.js ã® WebGL ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§æ¨è«–ã‚’å®Ÿè¡Œã€‚</li>
          <li>KNN åˆ†é¡å™¨ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®ãƒ©ãƒ™ãƒ«åˆ†é¡ã‚’å®Ÿæ–½ã€‚</li>
          <li>å®Œå…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§æ˜ åƒå‡¦ç†ãƒ»æ¨è«–ãƒ»è¡¨ç¤ºã‚’å®Œçµã€‚</li>
          <li>æ‰‹ã®éª¨æ ¼æ§‹é€ ã‚’æ¥ç¶šç·šã§å¯è¦–åŒ–ï¼ˆæŒ‡å…ˆã¯é»„è‰²ã§å¼·èª¿è¡¨ç¤ºï¼‰ã€‚</li>
          <li>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã®æ°¸ç¶šåŒ–ï¼ˆlocalStorage / JSONãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã«å¯¾å¿œã€‚</li>
          <li>Web Speech API ã«ã‚ˆã‚‹éŸ³å£°å…¥åŠ›ã§ãƒ©ãƒ™ãƒ«ç™»éŒ²ã€‚</li>
          <li>2å›è¨˜éŒ²ã®å¹³å‡åŒ–ã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿å“è³ªå‘ä¸Šã€‚</li>
        </ul>
        <h3>å‚è€ƒãƒªãƒ³ã‚¯</h3>
        <ul>
          <li><a href="https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker?hl=ja" target="_blank" rel="noopener noreferrer">æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¤œå‡ºã‚¬ã‚¤ãƒ‰</a></li>
          <li><a href="https://www.tensorflow.org/?hl=ja" target="_blank" rel="noopener noreferrer">TensorFlow</a></li>
        </ul>
      </div>
    </section>
  </div>

  <!-- MediaPipe Hands ã¨ TensorFlow.js ã‚’èª­ã¿è¾¼ã‚€ -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>

  <script>
    "use strict";

    // å®šæ•°
    const KNN_K_VALUE = 3;
    const MAX_HISTORY_LENGTH = 12;
    const STORAGE_KEY = "jsl_knn_data";
    const METADATA_KEY = "jsl_word_metadata";

    // æ‰‹ã®éª¨æ ¼æ§‹é€ ï¼ˆæ¥ç¶šç·šã®ãŸã‚ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ãƒšã‚¢ï¼‰
    const HAND_CONNECTIONS = [
      [0, 1], [0, 5], [0, 9], [0, 13], [0, 17],
      [1, 2], [2, 3], [3, 4],
      [5, 6], [6, 7], [7, 8],
      [9, 10], [10, 11], [11, 12],
      [13, 14], [14, 15], [15, 16],
      [17, 18], [18, 19], [19, 20],
      [5, 9], [9, 13], [13, 17]
    ];

    // è¨˜éŒ²çŠ¶æ…‹ã®å®šç¾©
    const RecordingState = {
      IDLE: 'idle',
      RECORDING_1: 'rec1',
      WAITING_2: 'wait2',
      RECORDING_2: 'rec2',
      LABELING: 'labeling'
    };

    // DOMè¦ç´  - èªè­˜ã‚¿ãƒ–
    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const thresholdInput = document.getElementById("threshold");
    const thresholdValue = document.getElementById("thresholdValue");
    const resultEl = document.getElementById("result");
    const scoreEl = document.getElementById("score");
    const historyEl = document.getElementById("history");
    const statusRecognizeEl = document.getElementById("statusRecognize");
    const modelLiteBtn = document.getElementById("modelLite");
    const modelFullBtn = document.getElementById("modelFull");

    // DOMè¦ç´  - è¨˜éŒ²ã‚¿ãƒ–
    const videoRecord = document.getElementById("videoRecord");
    const canvasRecord = document.getElementById("overlayRecord");
    const ctxRecord = canvasRecord.getContext("2d");
    const recordStatusEl = document.getElementById("recordStatus");
    const btnStartRecord = document.getElementById("btnStartRecord");
    const btnStopRecord = document.getElementById("btnStopRecord");
    const btnVoiceInput = document.getElementById("btnVoiceInput");
    const btnRegister = document.getElementById("btnRegister");
    const btnResetRecord = document.getElementById("btnResetRecord");
    const labelInputRecord = document.getElementById("labelInputRecord");
    const voiceInputArea = document.getElementById("voiceInputArea");
    const statusRecordEl = document.getElementById("statusRecord");
    const step1El = document.getElementById("step1");
    const step2El = document.getElementById("step2");
    const step3El = document.getElementById("step3");

    // DOMè¦ç´  - ä¸€è¦§ã‚¿ãƒ–
    const wordCountEl = document.getElementById("wordCount");
    const sortSelect = document.getElementById("sortSelect");
    const searchInput = document.getElementById("searchInput");
    const wordTableBody = document.getElementById("wordTableBody");
    const emptyStateEl = document.getElementById("emptyState");
    const selectAllCheckbox = document.getElementById("selectAll");
    const selectAllBulkCheckbox = document.getElementById("selectAllBulk");
    const btnDeleteSelected = document.getElementById("btnDeleteSelected");
    const saveToStorageBtn = document.getElementById("saveToStorage");
    const loadFromStorageBtn = document.getElementById("loadFromStorage");
    const exportFileBtn = document.getElementById("exportFile");
    const importFileBtn = document.getElementById("importFileBtn");
    const importFileInput = document.getElementById("importFile");
    const clearDataBtn = document.getElementById("clearData");
    const statusListEl = document.getElementById("statusList");

    // ã‚¿ãƒ–
    const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
    const tabPanels = Array.from(document.querySelectorAll(".tab-panel"));

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹
    let detector;
    let latestFeature = null;
    let latestFeatureRecord = null;
    let isPageVisible = true;
    let currentTab = 'tab-recognize';
    const knn = knnClassifier.create();
    const history = [];

    // è¨˜éŒ²ã‚¿ãƒ–ã®çŠ¶æ…‹
    let recordingState = RecordingState.IDLE;
    let recordData1 = [];
    let recordData2 = [];
    let averagedFeature = null;

    // å˜èªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
    let wordMetadata = {};

    // é¸æŠçŠ¶æ…‹
    let selectedLabels = new Set();

    // ãƒšãƒ¼ã‚¸å¯è¦–æ€§ã®ç›£è¦–
    document.addEventListener("visibilitychange", () => {
      isPageVisible = !document.hidden;
    });

    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
    function setActiveTab(targetId) {
      tabButtons.forEach((button) => {
        const isActive = button.getAttribute("aria-controls") === targetId;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-selected", isActive);
      });
      tabPanels.forEach((panel) => {
        panel.classList.toggle("active", panel.id === targetId);
      });
      currentTab = targetId;

      if (targetId === 'tab-list') {
        updateWordList();
      }
    }

    tabButtons.forEach((button) => {
      button.addEventListener("click", () => {
        setActiveTab(button.getAttribute("aria-controls"));
      });
    });

    // ã—ãã„å€¤ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡¨ç¤ºæ›´æ–°
    thresholdInput.addEventListener("input", () => {
      thresholdValue.textContent = thresholdInput.value;
    });

    // ãƒ¢ãƒ‡ãƒ«åˆ‡æ›¿
    modelLiteBtn.addEventListener("click", () => toggleModel("lite"));
    modelFullBtn.addEventListener("click", () => toggleModel("full"));

    function toggleModel(type) {
      localStorage.setItem("mp_model_type", type);
      modelLiteBtn.classList.toggle("active", type === "lite");
      modelFullBtn.classList.toggle("active", type === "full");
      statusRecognizeEl.textContent = "ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚å†èª­ã¿è¾¼ã¿ã§é©ç”¨ã•ã‚Œã¾ã™ã€‚";
    }

    const savedModelType = localStorage.getItem("mp_model_type") || "lite";
    modelLiteBtn.classList.toggle("active", savedModelType === "lite");
    modelFullBtn.classList.toggle("active", savedModelType === "full");

    // ã‚«ãƒ¡ãƒ©æ˜ åƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    async function setupCamera(videoElement) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false,
        });
        videoElement.srcObject = stream;
        await videoElement.play();
      } catch (error) {
        if (error.name === "NotAllowedError") {
          throw new Error("ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        } else if (error.name === "NotFoundError") {
          throw new Error("ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚«ãƒ¡ãƒ©ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        } else if (error.name === "NotReadableError") {
          throw new Error("ã‚«ãƒ¡ãƒ©ãŒä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ä¸­ã§ã™ã€‚");
        }
        throw error;
      }
    }

    // æ‰‹ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
    async function setupDetector() {
      await tf.setBackend("webgl");
      await tf.ready();

      const model = handPoseDetection.SupportedModels.MediaPipeHands;
      detector = await handPoseDetection.createDetector(model, {
        runtime: "mediapipe",
        modelType: savedModelType,
        maxHands: 2,
        solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
      });
    }

    // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‹ã‚‰ç‰¹å¾´é‡ã‚’ç”Ÿæˆ
    function landmarksToFeatures(landmarks) {
      const wrist = landmarks[0];
      const middleTip = landmarks[12];
      const scale = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y) || 1;
      return landmarks.flatMap((pt) => [
        (pt.x - wrist.x) / scale,
        (pt.y - wrist.y) / scale,
        (pt.z - wrist.z) / scale,
      ]);
    }

    // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚’åˆ†é¡
    async function classifyGesture(featureVector) {
      if (knn.getNumClasses() === 0) {
        resultEl.textContent = "æœªå­¦ç¿’";
        scoreEl.textContent = "score: --";
        return;
      }

      const tensor = tf.tensor(featureVector);
      try {
        const result = await knn.predictClass(tensor, KNN_K_VALUE);
        const label = result.label;
        const confidence = result.confidences[label] || 0;
        scoreEl.textContent = `score: ${confidence.toFixed(2)}`;

        if (confidence >= parseFloat(thresholdInput.value)) {
          resultEl.textContent = label;
          pushHistory(label, confidence);
        } else {
          resultEl.textContent = "--";
        }
      } finally {
        tensor.dispose();
      }
    }

    function pushHistory(label, confidence) {
      const timestamp = new Date().toLocaleTimeString();
      history.unshift({ timestamp, label, confidence });
      if (history.length > MAX_HISTORY_LENGTH) history.pop();

      historyEl.innerHTML = "";
      history.forEach((item) => {
        const div = document.createElement("div");
        div.className = "history-item";
        div.textContent = `${item.timestamp}ï¼š${item.label} (${item.confidence.toFixed(2)})`;
        historyEl.appendChild(div);
      });
    }

    // æ‰‹ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’æç”»
    function drawLandmarks(predictions, context, canvasEl) {
      context.clearRect(0, 0, canvasEl.width, canvasEl.height);

      predictions.forEach((prediction) => {
        const { keypoints } = prediction;

        context.strokeStyle = "rgba(56, 189, 248, 0.6)";
        context.lineWidth = 2;
        HAND_CONNECTIONS.forEach(([startIdx, endIdx]) => {
          const start = keypoints[startIdx];
          const end = keypoints[endIdx];
          if (start && end) {
            context.beginPath();
            context.moveTo(start.x, start.y);
            context.lineTo(end.x, end.y);
            context.stroke();
          }
        });

        context.fillStyle = "rgba(56, 189, 248, 0.9)";
        keypoints.forEach((pt, idx) => {
          context.beginPath();
          const radius = (idx === 0 || idx % 4 === 0) ? 6 : 4;
          context.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
          context.fill();
        });

        context.fillStyle = "#fbbf24";
        [4, 8, 12, 16, 20].forEach((tipIdx) => {
          const tip = keypoints[tipIdx];
          if (tip) {
            context.beginPath();
            context.arc(tip.x, tip.y, 5, 0, Math.PI * 2);
            context.fill();
          }
        });
      });
    }

    // canvasã‚µã‚¤ã‚ºã‚’videoã«åˆã‚ã›ã‚‹
    function syncCanvasSize(videoEl, canvasEl) {
      if (canvasEl.width !== videoEl.videoWidth || canvasEl.height !== videoEl.videoHeight) {
        canvasEl.width = videoEl.videoWidth;
        canvasEl.height = videoEl.videoHeight;
      }
    }

    // èªè­˜ã‚¿ãƒ–ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ«ãƒ¼ãƒ—
    async function renderLoopRecognize() {
      if (!isPageVisible || currentTab !== 'tab-recognize') {
        requestAnimationFrame(renderLoopRecognize);
        return;
      }

      const predictions = await detector.estimateHands(video, { flipHorizontal: false });
      syncCanvasSize(video, canvas);

      if (predictions.length > 0) {
        drawLandmarks(predictions, ctx, canvas);
        latestFeature = landmarksToFeatures(predictions[0].keypoints);
        await classifyGesture(latestFeature);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        resultEl.textContent = "--";
      }

      requestAnimationFrame(renderLoopRecognize);
    }

    // è¨˜éŒ²ã‚¿ãƒ–ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ«ãƒ¼ãƒ—
    async function renderLoopRecord() {
      if (!isPageVisible || currentTab !== 'tab-record') {
        requestAnimationFrame(renderLoopRecord);
        return;
      }

      const predictions = await detector.estimateHands(videoRecord, { flipHorizontal: false });
      syncCanvasSize(videoRecord, canvasRecord);

      if (predictions.length > 0) {
        drawLandmarks(predictions, ctxRecord, canvasRecord);
        latestFeatureRecord = landmarksToFeatures(predictions[0].keypoints);

        // è¨˜éŒ²ä¸­ãªã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
        if (recordingState === RecordingState.RECORDING_1) {
          recordData1.push([...latestFeatureRecord]);
        } else if (recordingState === RecordingState.RECORDING_2) {
          recordData2.push([...latestFeatureRecord]);
        }
      } else {
        ctxRecord.clearRect(0, 0, canvasRecord.width, canvasRecord.height);
        latestFeatureRecord = null;
      }

      requestAnimationFrame(renderLoopRecord);
    }

    // è¨˜éŒ²çŠ¶æ…‹ã®æ›´æ–°
    function updateRecordingState(newState) {
      recordingState = newState;

      // ã‚¹ãƒ†ãƒƒãƒ—è¡¨ç¤ºã®æ›´æ–°
      step1El.classList.remove('active', 'completed');
      step2El.classList.remove('active', 'completed');
      step3El.classList.remove('active', 'completed');

      switch (newState) {
        case RecordingState.IDLE:
          step1El.classList.add('active');
          recordStatusEl.textContent = 'å¾…æ©Ÿä¸­ - ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„';
          recordStatusEl.className = 'record-status idle';
          btnStartRecord.disabled = false;
          btnStopRecord.disabled = true;
          voiceInputArea.classList.add('hidden');
          break;
        case RecordingState.RECORDING_1:
          step1El.classList.add('active');
          recordStatusEl.textContent = 'è¨˜éŒ²ä¸­ï¼ˆ1å›ç›®ï¼‰...';
          recordStatusEl.className = 'record-status recording';
          btnStartRecord.disabled = true;
          btnStopRecord.disabled = false;
          break;
        case RecordingState.WAITING_2:
          step1El.classList.add('completed');
          step2El.classList.add('active');
          recordStatusEl.textContent = '1å›ç›®å®Œäº† - 2å›ç›®ã®ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„';
          recordStatusEl.className = 'record-status waiting';
          btnStartRecord.disabled = false;
          btnStopRecord.disabled = true;
          break;
        case RecordingState.RECORDING_2:
          step1El.classList.add('completed');
          step2El.classList.add('active');
          recordStatusEl.textContent = 'è¨˜éŒ²ä¸­ï¼ˆ2å›ç›®ï¼‰...';
          recordStatusEl.className = 'record-status recording';
          btnStartRecord.disabled = true;
          btnStopRecord.disabled = false;
          break;
        case RecordingState.LABELING:
          step1El.classList.add('completed');
          step2El.classList.add('completed');
          step3El.classList.add('active');
          recordStatusEl.textContent = 'å˜èªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
          recordStatusEl.className = 'record-status labeling';
          btnStartRecord.disabled = true;
          btnStopRecord.disabled = true;
          voiceInputArea.classList.remove('hidden');
          break;
      }
    }

    // 2å›ã®è¨˜éŒ²ãƒ‡ãƒ¼ã‚¿ã‚’å¹³å‡åŒ–
    function averageRecordData(data1, data2) {
      if (data1.length === 0 || data2.length === 0) {
        return null;
      }

      // å„è¨˜éŒ²ã®å…¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å¹³å‡åŒ–ã—ã¦ä»£è¡¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
      const avg1 = new Array(63).fill(0);
      data1.forEach(frame => {
        frame.forEach((val, i) => avg1[i] += val);
      });
      avg1.forEach((_, i) => avg1[i] /= data1.length);

      const avg2 = new Array(63).fill(0);
      data2.forEach(frame => {
        frame.forEach((val, i) => avg2[i] += val);
      });
      avg2.forEach((_, i) => avg2[i] /= data2.length);

      // 2å›ã®ä»£è¡¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å¹³å‡åŒ–
      const result = new Array(63);
      for (let i = 0; i < 63; i++) {
        result[i] = (avg1[i] + avg2[i]) / 2;
      }
      return result;
    }

    // è¨˜éŒ²é–‹å§‹
    btnStartRecord.addEventListener('click', () => {
      if (recordingState === RecordingState.IDLE) {
        recordData1 = [];
        updateRecordingState(RecordingState.RECORDING_1);
        statusRecordEl.textContent = 'æ‰‹è©±ã‚’å®Ÿæ¼”ã—ã¦ãã ã•ã„...';
      } else if (recordingState === RecordingState.WAITING_2) {
        recordData2 = [];
        updateRecordingState(RecordingState.RECORDING_2);
        statusRecordEl.textContent = 'æ‰‹è©±ã‚’å®Ÿæ¼”ã—ã¦ãã ã•ã„...';
      }
    });

    // è¨˜éŒ²çµ‚äº†
    btnStopRecord.addEventListener('click', () => {
      if (recordingState === RecordingState.RECORDING_1) {
        if (recordData1.length < 10) {
          statusRecordEl.textContent = 'ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã™ãã¾ã™ã€‚ã‚‚ã†å°‘ã—é•·ãè¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚';
          return;
        }
        statusRecordEl.textContent = `1å›ç›®: ${recordData1.length}ãƒ•ãƒ¬ãƒ¼ãƒ è¨˜éŒ²`;
        updateRecordingState(RecordingState.WAITING_2);
      } else if (recordingState === RecordingState.RECORDING_2) {
        if (recordData2.length < 10) {
          statusRecordEl.textContent = 'ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã™ãã¾ã™ã€‚ã‚‚ã†å°‘ã—é•·ãè¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚';
          return;
        }
        statusRecordEl.textContent = `2å›ç›®: ${recordData2.length}ãƒ•ãƒ¬ãƒ¼ãƒ è¨˜éŒ² - å¹³å‡åŒ–å‡¦ç†å®Œäº†`;
        averagedFeature = averageRecordData(recordData1, recordData2);
        updateRecordingState(RecordingState.LABELING);
      }
    });

    // éŸ³å£°å…¥åŠ›
    btnVoiceInput.addEventListener('click', () => {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        statusRecordEl.textContent = 'éŸ³å£°èªè­˜ã¯ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
        return;
      }

      const recognition = new SpeechRecognition();
      recognition.lang = 'ja-JP';
      recognition.continuous = false;
      recognition.interimResults = false;

      btnVoiceInput.disabled = true;
      btnVoiceInput.textContent = 'ğŸ¤ èªè­˜ä¸­...';

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        labelInputRecord.value = transcript;
        statusRecordEl.textContent = `éŸ³å£°èªè­˜: "${transcript}"`;
      };

      recognition.onerror = (event) => {
        statusRecordEl.textContent = `éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: ${event.error}`;
      };

      recognition.onend = () => {
        btnVoiceInput.disabled = false;
        btnVoiceInput.textContent = 'ğŸ¤ éŸ³å£°å…¥åŠ›';
      };

      recognition.start();
    });

    // ç™»éŒ²
    btnRegister.addEventListener('click', () => {
      const label = labelInputRecord.value.trim();
      if (!label) {
        statusRecordEl.textContent = 'å˜èªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
        return;
      }
      if (!averagedFeature) {
        statusRecordEl.textContent = 'ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚è¨˜éŒ²ã‚’ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚';
        return;
      }

      const tensor = tf.tensor(averagedFeature);
      knn.addExample(tensor, label);
      tensor.dispose();

      // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
      const now = new Date().toISOString();
      if (!wordMetadata[label]) {
        wordMetadata[label] = { createdAt: now, updatedAt: now };
      } else {
        wordMetadata[label].updatedAt = now;
      }
      saveMetadata();

      statusRecordEl.textContent = `ã€Œ${label}ã€ã‚’ç™»éŒ²ã—ã¾ã—ãŸï¼`;
      labelInputRecord.value = '';
      resetRecording();
    });

    // ãƒªã‚»ãƒƒãƒˆ
    btnResetRecord.addEventListener('click', resetRecording);

    function resetRecording() {
      recordData1 = [];
      recordData2 = [];
      averagedFeature = null;
      labelInputRecord.value = '';
      updateRecordingState(RecordingState.IDLE);
    }

    // éŸ³å£°èªè­˜ã®å¯¾å¿œç¢ºèª
    function checkSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        btnVoiceInput.style.display = 'none';
      }
    }

    // ===== ä¸€è¦§ã‚¿ãƒ–ã®æ©Ÿèƒ½ =====

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜
    function saveMetadata() {
      localStorage.setItem(METADATA_KEY, JSON.stringify(wordMetadata));
    }

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
    function loadMetadata() {
      const stored = localStorage.getItem(METADATA_KEY);
      if (stored) {
        wordMetadata = JSON.parse(stored);
      }
    }

    // å˜èªä¸€è¦§ã®æ›´æ–°
    function updateWordList() {
      const counts = knn.getClassExampleCount();
      const labels = Object.keys(counts);
      const searchQuery = searchInput.value.toLowerCase();
      const sortValue = sortSelect.value;

      // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      let filteredLabels = labels.filter(label =>
        label.toLowerCase().includes(searchQuery)
      );

      // ã‚½ãƒ¼ãƒˆ
      const [sortKey, sortOrder] = sortValue.split('-');
      filteredLabels.sort((a, b) => {
        let comparison = 0;
        if (sortKey === 'name') {
          comparison = a.localeCompare(b, 'ja');
        } else if (sortKey === 'count') {
          comparison = counts[a] - counts[b];
        } else if (sortKey === 'date') {
          const dateA = wordMetadata[a]?.createdAt || '1970-01-01';
          const dateB = wordMetadata[b]?.createdAt || '1970-01-01';
          comparison = dateA.localeCompare(dateB);
        }
        return sortOrder === 'desc' ? -comparison : comparison;
      });

      // ä»¶æ•°æ›´æ–°
      wordCountEl.textContent = `ç™»éŒ²æ•°: ${labels.length}ä»¶`;

      // ãƒ†ãƒ¼ãƒ–ãƒ«æ›´æ–°
      wordTableBody.innerHTML = '';

      if (filteredLabels.length === 0) {
        emptyStateEl.classList.remove('hidden');
        document.querySelector('.word-table').style.display = 'none';
      } else {
        emptyStateEl.classList.add('hidden');
        document.querySelector('.word-table').style.display = '';

        filteredLabels.forEach(label => {
          const tr = document.createElement('tr');
          const metadata = wordMetadata[label] || {};
          const dateStr = metadata.createdAt
            ? new Date(metadata.createdAt).toLocaleString('ja-JP')
            : '-';

          tr.innerHTML = `
            <td><input type="checkbox" class="word-checkbox" data-label="${escapeHtml(label)}" ${selectedLabels.has(label) ? 'checked' : ''} /></td>
            <td>${escapeHtml(label)}</td>
            <td>${counts[label]}</td>
            <td>${dateStr}</td>
            <td><button class="btn btn-danger btn-delete" data-label="${escapeHtml(label)}" style="padding: 4px 8px; font-size: 0.8rem;">å‰Šé™¤</button></td>
          `;
          wordTableBody.appendChild(tr);
        });

        // å‰Šé™¤ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        wordTableBody.querySelectorAll('.btn-delete').forEach(btn => {
          btn.addEventListener('click', () => {
            const label = btn.dataset.label;
            if (confirm(`ã€Œ${label}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
              deleteWord(label);
            }
          });
        });

        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        wordTableBody.querySelectorAll('.word-checkbox').forEach(cb => {
          cb.addEventListener('change', () => {
            if (cb.checked) {
              selectedLabels.add(cb.dataset.label);
            } else {
              selectedLabels.delete(cb.dataset.label);
            }
            updateBulkDeleteButton();
          });
        });
      }

      updateBulkDeleteButton();
    }

    // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // å˜èªå‰Šé™¤
    function deleteWord(label) {
      // KNNã‹ã‚‰å‰Šé™¤
      const dataset = knn.getClassifierDataset();
      if (dataset[label]) {
        dataset[label].dispose();
        delete dataset[label];
        knn.setClassifierDataset(dataset);
      }

      // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤
      delete wordMetadata[label];
      saveMetadata();

      // é¸æŠã‹ã‚‰å‰Šé™¤
      selectedLabels.delete(label);

      statusListEl.textContent = `ã€Œ${label}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`;
      updateWordList();
    }

    // ä¸€æ‹¬å‰Šé™¤ãƒœã‚¿ãƒ³ã®æ›´æ–°
    function updateBulkDeleteButton() {
      btnDeleteSelected.disabled = selectedLabels.size === 0;
    }

    // æ¤œç´¢
    searchInput.addEventListener('input', () => {
      selectedLabels.clear();
      updateWordList();
    });

    // ã‚½ãƒ¼ãƒˆ
    sortSelect.addEventListener('change', updateWordList);

    // å…¨é¸æŠ
    selectAllCheckbox.addEventListener('change', () => {
      const checkboxes = wordTableBody.querySelectorAll('.word-checkbox');
      checkboxes.forEach(cb => {
        cb.checked = selectAllCheckbox.checked;
        if (selectAllCheckbox.checked) {
          selectedLabels.add(cb.dataset.label);
        } else {
          selectedLabels.delete(cb.dataset.label);
        }
      });
      updateBulkDeleteButton();
    });

    selectAllBulkCheckbox.addEventListener('change', () => {
      selectAllCheckbox.checked = selectAllBulkCheckbox.checked;
      selectAllCheckbox.dispatchEvent(new Event('change'));
    });

    // é¸æŠé …ç›®å‰Šé™¤
    btnDeleteSelected.addEventListener('click', () => {
      if (selectedLabels.size === 0) return;
      if (!confirm(`é¸æŠã—ãŸ ${selectedLabels.size} ä»¶ã®å˜èªã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;

      selectedLabels.forEach(label => {
        const dataset = knn.getClassifierDataset();
        if (dataset[label]) {
          dataset[label].dispose();
          delete dataset[label];
        }
        delete wordMetadata[label];
      });

      knn.setClassifierDataset(knn.getClassifierDataset());
      saveMetadata();

      statusListEl.textContent = `${selectedLabels.size}ä»¶ã®å˜èªã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`;
      selectedLabels.clear();
      updateWordList();
    });

    // ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====

    // KNNãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
    async function serializeKnnData() {
      const dataset = knn.getClassifierDataset();
      const dataObj = {};
      for (const label of Object.keys(dataset)) {
        dataObj[label] = Array.from(await dataset[label].data());
        dataObj[label + "_shape"] = dataset[label].shape;
      }
      return dataObj;
    }

    // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ãŸãƒ‡ãƒ¼ã‚¿ã‹ã‚‰KNNã‚’å¾©å…ƒ
    function deserializeKnnData(dataObj) {
      const dataset = {};
      const labels = Object.keys(dataObj).filter(k => !k.endsWith("_shape"));
      for (const label of labels) {
        const shape = dataObj[label + "_shape"];
        dataset[label] = tf.tensor2d(dataObj[label], shape);
      }
      knn.setClassifierDataset(dataset);
    }

    // localStorageã«ä¿å­˜
    saveToStorageBtn.addEventListener("click", async () => {
      if (knn.getNumClasses() === 0) {
        statusListEl.textContent = "ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚";
        return;
      }
      try {
        const data = await serializeKnnData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        saveMetadata();
        statusListEl.textContent = "localStorageã«ä¿å­˜ã—ã¾ã—ãŸã€‚";
      } catch (error) {
        console.error(error);
        statusListEl.textContent = "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
      }
    });

    // localStorageã‹ã‚‰å¾©å…ƒ
    loadFromStorageBtn.addEventListener("click", () => {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) {
          statusListEl.textContent = "ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚";
          return;
        }
        const data = JSON.parse(stored);
        deserializeKnnData(data);
        loadMetadata();
        updateWordList();
        statusListEl.textContent = "localStorageã‹ã‚‰å¾©å…ƒã—ã¾ã—ãŸã€‚";
      } catch (error) {
        console.error(error);
        statusListEl.textContent = "å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
      }
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    exportFileBtn.addEventListener("click", async () => {
      if (knn.getNumClasses() === 0) {
        statusListEl.textContent = "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚";
        return;
      }
      try {
        const knnData = await serializeKnnData();
        const exportData = {
          version: 2,
          metadata: wordMetadata,
          knnData: knnData
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `jsl-training-data-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        statusListEl.textContent = "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚";
      } catch (error) {
        console.error(error);
        statusListEl.textContent = "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
      }
    });

    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³
    importFileBtn.addEventListener("click", () => {
      importFileInput.click();
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    importFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // ãƒãƒ¼ã‚¸ãƒ§ãƒ³2å½¢å¼ã®å ´åˆ
          if (data.version === 2) {
            deserializeKnnData(data.knnData);
            wordMetadata = data.metadata || {};
          } else {
            // æ—§å½¢å¼ã¨ã®äº’æ›æ€§
            deserializeKnnData(data);
          }

          saveMetadata();
          updateWordList();
          statusListEl.textContent = `${file.name} ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚`;
        } catch (error) {
          console.error(error);
          statusListEl.textContent = "ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
        }
      };
      reader.readAsText(file);
      event.target.value = "";
    });

    // ãƒ‡ãƒ¼ã‚¿ã‚’å…¨å‰Šé™¤
    clearDataBtn.addEventListener("click", () => {
      if (!confirm("ã™ã¹ã¦ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) {
        return;
      }
      knn.clearAllClasses();
      wordMetadata = {};
      saveMetadata();
      selectedLabels.clear();
      updateWordList();
      statusListEl.textContent = "ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚";
    });

    // ===== åˆæœŸåŒ– =====

    async function init() {
      try {
        statusRecognizeEl.textContent = "ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ä¸­...";
        statusRecordEl.textContent = "ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ä¸­...";

        await setupCamera(video);
        await setupCamera(videoRecord);

        statusRecognizeEl.textContent = "ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...";
        statusRecordEl.textContent = "ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...";

        await setupDetector();

        loadMetadata();
        checkSpeechRecognition();

        statusRecognizeEl.textContent = "æº–å‚™å®Œäº†ã€‚æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«ã‹ã–ã—ã¦ãã ã•ã„ã€‚";
        statusRecordEl.textContent = "æº–å‚™å®Œäº†";

        renderLoopRecognize();
        renderLoopRecord();
      } catch (error) {
        console.error(error);
        const errorMsg = error.message || "åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
        statusRecognizeEl.textContent = errorMsg;
        statusRecordEl.textContent = errorMsg;
      }
    }

    init();
  </script>
</body>
</html>
