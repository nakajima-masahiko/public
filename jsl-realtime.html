<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSL リアルタイム認識デモ</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: #1e293b;
      --text: #f8fafc;
      --accent: #38bdf8;
    }
    body {
      margin: 0;
      font-family: "Noto Sans JP", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
    }
    .tab-shell {
      display: grid;
      gap: 16px;
    }
    .tabs {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tab-button {
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 8px 16px;
      background: #334155;
      color: inherit;
      cursor: pointer;
      font-weight: 600;
    }
    .tab-button.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.2);
    }
    .tab-panel {
      display: none;
    }
    .tab-panel.active {
      display: block;
    }
    .app {
      display: grid;
      grid-template-columns: minmax(300px, 1fr) 320px;
      gap: 20px;
    }
    header {
      grid-column: 1 / -1;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }
    p {
      margin: 0;
      opacity: 0.8;
    }
    .video-wrap {
      position: relative;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      min-height: 320px;
    }
    video, canvas {
      width: 100%;
      height: 100%;
      display: block;
      transform: scaleX(-1);
    }
    canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .control {
      display: grid;
      gap: 8px;
    }
    label {
      font-weight: 600;
    }
    input[type="range"] {
      width: 100%;
    }
    .toggle {
      display: inline-flex;
      gap: 8px;
    }
    .toggle button {
      flex: 1;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 8px 12px;
      background: #334155;
      color: inherit;
      cursor: pointer;
    }
    .toggle button.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.2);
    }
    .result {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent);
    }
    .history {
      max-height: 220px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
    }
    .history-item {
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      font-size: 0.95rem;
    }
    .small {
      font-size: 0.85rem;
      opacity: 0.8;
    }
    .status {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    .train {
      display: grid;
      gap: 6px;
    }
    .train input {
      padding: 6px;
      border-radius: 8px;
      border: 1px solid #475569;
      background: transparent;
      color: inherit;
    }
    .train button {
      border-radius: 8px;
      border: none;
      padding: 8px;
      background: var(--accent);
      color: #0f172a;
      font-weight: 600;
      cursor: pointer;
    }
    .info-panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 20px;
      display: grid;
      gap: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-panel ol {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 8px;
    }
    .info-panel ul {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 6px;
    }
    .info-panel a {
      color: var(--accent);
    }
    .data-controls {
      display: grid;
      gap: 8px;
    }
    .data-controls .btn-row {
      display: flex;
      gap: 8px;
    }
    .data-controls button {
      flex: 1;
      border-radius: 8px;
      border: none;
      padding: 8px;
      background: #475569;
      color: inherit;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .data-controls button:hover {
      background: #64748b;
    }
    .data-controls button.primary {
      background: var(--accent);
      color: #0f172a;
    }
    .data-controls button.danger {
      background: #ef4444;
      color: white;
    }
    .data-controls input[type="file"] {
      display: none;
    }
    .sample-count {
      font-size: 0.85rem;
      opacity: 0.8;
      padding: 4px 0;
    }
  </style>
</head>
<body>
  <div class="tab-shell">
    <div class="tabs" role="tablist" aria-label="デモ切り替え">
      <button class="tab-button active" role="tab" aria-selected="true" aria-controls="tab-run" id="tabButtonRun" type="button">実行</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-manual" id="tabButtonManual" type="button">マニュアル</button>
      <button class="tab-button" role="tab" aria-selected="false" aria-controls="tab-spec" id="tabButtonSpec" type="button">仕様</button>
    </div>

    <section id="tab-run" class="tab-panel active" role="tabpanel" aria-labelledby="tabButtonRun">
      <div class="app">
        <header>
          <h1>日本手話 (JSL) リアルタイム認識 デモ</h1>
          <p>MediaPipe Hands と TensorFlow.js (KNN) を使った完全クライアントサイドのベース実装です。</p>
        </header>

        <div class="video-wrap">
          <video id="video" autoplay playsinline aria-label="カメラ映像"></video>
          <canvas id="overlay"></canvas>
        </div>

        <aside class="panel">
          <div class="control">
            <label for="threshold">認識信頼度しきい値: <span id="thresholdValue">0.75</span></label>
            <input id="threshold" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div class="control">
            <label>モデル種類</label>
            <div class="toggle">
              <button id="modelLite" class="active" type="button">高速 (Lite)</button>
              <button id="modelFull" type="button">高精度 (Full)</button>
            </div>
            <div class="small">※ モデル切替後は再読み込みが必要です。</div>
          </div>

          <div class="control">
            <label>認識結果</label>
            <div id="result" class="result">--</div>
            <div id="score" class="small">score: --</div>
          </div>

          <div class="control">
            <label>履歴</label>
            <div id="history" class="history"></div>
          </div>

          <div class="control train">
            <label>サンプル登録（任意）</label>
            <input id="labelInput" type="text" placeholder="例: あ / い / ありがとう" />
            <button id="addSample" type="button">現在の手形を学習データに追加</button>
            <div class="small">※ 本番用は事前に十分な学習データを用意してください。</div>
          </div>

          <div class="control data-controls">
            <label>学習データ管理</label>
            <div id="sampleCount" class="sample-count">登録サンプル数: 0</div>
            <div class="btn-row">
              <button id="saveToStorage" type="button" class="primary">保存 (Storage)</button>
              <button id="loadFromStorage" type="button">復元 (Storage)</button>
            </div>
            <div class="btn-row">
              <button id="exportFile" type="button">エクスポート</button>
              <button id="importFileBtn" type="button">インポート</button>
              <input id="importFile" type="file" accept=".json" />
            </div>
            <div class="btn-row">
              <button id="clearData" type="button" class="danger">全データ削除</button>
            </div>
          </div>

          <div id="status" class="status">初期化中...</div>
        </aside>
      </div>
    </section>

    <section id="tab-manual" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonManual">
      <div class="info-panel">
        <h2>使い方</h2>
        <ol>
          <li>「実行」タブでカメラアクセスを許可します。</li>
          <li>手をカメラに映し、ランドマーク（点と接続線）が表示されることを確認します。</li>
          <li>認識結果のしきい値をスライダーで調整します。</li>
          <li>必要に応じて「サンプル登録」でラベルを入力し、現在の手形を学習に追加します。</li>
          <li>履歴やスコアを確認しながら動作をチェックします。</li>
        </ol>
        <h3>学習データ管理</h3>
        <ul>
          <li><strong>保存 (Storage)</strong>: 学習データをブラウザのlocalStorageに保存します。</li>
          <li><strong>復元 (Storage)</strong>: localStorageから学習データを読み込みます。</li>
          <li><strong>エクスポート</strong>: 学習データをJSONファイルとしてダウンロードします。</li>
          <li><strong>インポート</strong>: JSONファイルから学習データを読み込みます。</li>
          <li><strong>全データ削除</strong>: すべての学習データを消去します。</li>
        </ul>
        <div>
          <a href="https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker?hl=ja" target="_blank" rel="noopener noreferrer">手のランドマーク検出ガイド</a>
        </div>
      </div>
    </section>

    <section id="tab-spec" class="tab-panel" role="tabpanel" aria-labelledby="tabButtonSpec">
      <div class="info-panel">
        <h2>仕様・使用技術</h2>
        <ul>
          <li>MediaPipe Hands による手のランドマーク検出（21点）。</li>
          <li>TensorFlow.js の WebGL バックエンドで推論を実行。</li>
          <li>KNN 分類器でリアルタイムのラベル分類を実施。</li>
          <li>完全クライアントサイドで映像処理・推論・表示を完結。</li>
          <li>手の骨格構造を接続線で可視化（指先は黄色で強調表示）。</li>
          <li>学習データの永続化（localStorage / JSONファイル）に対応。</li>
        </ul>
        <div>
          <a href="https://www.tensorflow.org/?hl=ja" target="_blank" rel="noopener noreferrer">TensorFlow</a>
        </div>
      </div>
    </section>
  </div>

  <!-- MediaPipe Hands と TensorFlow.js を読み込む -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>

  <script>
    "use strict";

    // 定数
    const KNN_K_VALUE = 3;
    const MAX_HISTORY_LENGTH = 12;

    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const thresholdInput = document.getElementById("threshold");
    const thresholdValue = document.getElementById("thresholdValue");
    const resultEl = document.getElementById("result");
    const scoreEl = document.getElementById("score");
    const historyEl = document.getElementById("history");
    const statusEl = document.getElementById("status");
    const modelLiteBtn = document.getElementById("modelLite");
    const modelFullBtn = document.getElementById("modelFull");
    const labelInput = document.getElementById("labelInput");
    const addSampleBtn = document.getElementById("addSample");
    const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
    const tabPanels = Array.from(document.querySelectorAll(".tab-panel"));
    const sampleCountEl = document.getElementById("sampleCount");
    const saveToStorageBtn = document.getElementById("saveToStorage");
    const loadFromStorageBtn = document.getElementById("loadFromStorage");
    const exportFileBtn = document.getElementById("exportFile");
    const importFileBtn = document.getElementById("importFileBtn");
    const importFileInput = document.getElementById("importFile");
    const clearDataBtn = document.getElementById("clearData");

    // localStorageキー
    const STORAGE_KEY = "jsl_knn_data";

    // 手の骨格構造（接続線のためのランドマークペア）
    const HAND_CONNECTIONS = [
      // 手首から各指の付け根へ
      [0, 1], [0, 5], [0, 9], [0, 13], [0, 17],
      // 親指
      [1, 2], [2, 3], [3, 4],
      // 人差し指
      [5, 6], [6, 7], [7, 8],
      // 中指
      [9, 10], [10, 11], [11, 12],
      // 薬指
      [13, 14], [14, 15], [15, 16],
      // 小指
      [17, 18], [18, 19], [19, 20],
      // 手のひらの横の接続
      [5, 9], [9, 13], [13, 17]
    ];

    let detector;
    let latestFeature = null;
    let isPageVisible = true;
    const knn = knnClassifier.create();
    const history = [];

    // ページ可視性の監視（非表示時にループを停止）
    document.addEventListener("visibilitychange", () => {
      isPageVisible = !document.hidden;
    });

    function setActiveTab(targetId) {
      tabButtons.forEach((button) => {
        const isActive = button.getAttribute("aria-controls") === targetId;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-selected", isActive);
      });
      tabPanels.forEach((panel) => {
        panel.classList.toggle("active", panel.id === targetId);
      });
    }

    tabButtons.forEach((button) => {
      button.addEventListener("click", () => {
        setActiveTab(button.getAttribute("aria-controls"));
      });
    });

    // しきい値スライダーの表示更新
    thresholdInput.addEventListener("input", () => {
      thresholdValue.textContent = thresholdInput.value;
    });

    // モデル切替（簡易版なので再読み込みを案内）
    modelLiteBtn.addEventListener("click", () => toggleModel("lite"));
    modelFullBtn.addEventListener("click", () => toggleModel("full"));

    function toggleModel(type) {
      localStorage.setItem("mp_model_type", type);
      modelLiteBtn.classList.toggle("active", type === "lite");
      modelFullBtn.classList.toggle("active", type === "full");
      statusEl.textContent = "モデルタイプを保存しました。再読み込みで適用されます。";
    }

    // モデルタイプを初期化
    const savedModelType = localStorage.getItem("mp_model_type") || "lite";
    modelLiteBtn.classList.toggle("active", savedModelType === "lite");
    modelFullBtn.classList.toggle("active", savedModelType === "full");

    // カメラ映像のセットアップ
    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false,
        });
        video.srcObject = stream;
        await video.play();
      } catch (error) {
        if (error.name === "NotAllowedError") {
          throw new Error("カメラへのアクセスが拒否されました。ブラウザの設定を確認してください。");
        } else if (error.name === "NotFoundError") {
          throw new Error("カメラが見つかりません。カメラが接続されているか確認してください。");
        } else if (error.name === "NotReadableError") {
          throw new Error("カメラが他のアプリケーションで使用中です。");
        }
        throw error;
      }
    }

    // 手ランドマーク検出モデルの初期化
    async function setupDetector() {
      await tf.setBackend("webgl");
      await tf.ready();

      const model = handPoseDetection.SupportedModels.MediaPipeHands;
      detector = await handPoseDetection.createDetector(model, {
        runtime: "mediapipe",
        modelType: savedModelType,
        maxHands: 2,
        solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
      });
    }

    // ランドマークから特徴量を生成（正規化してフラット化）
    function landmarksToFeatures(landmarks) {
      const wrist = landmarks[0];
      const middleTip = landmarks[12];
      const scale = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y) || 1;
      return landmarks.flatMap((pt) => [
        (pt.x - wrist.x) / scale,
        (pt.y - wrist.y) / scale,
        (pt.z - wrist.z) / scale,
      ]);
    }

    // ジェスチャーを分類して結果を表示
    async function classifyGesture(featureVector) {
      if (knn.getNumClasses() === 0) {
        resultEl.textContent = "未学習";
        scoreEl.textContent = "score: --";
        return;
      }

      const tensor = tf.tensor(featureVector);
      try {
        const result = await knn.predictClass(tensor, KNN_K_VALUE);
        const label = result.label;
        const confidence = result.confidences[label] || 0;
        scoreEl.textContent = `score: ${confidence.toFixed(2)}`;

        if (confidence >= parseFloat(thresholdInput.value)) {
          resultEl.textContent = label;
          pushHistory(label, confidence);
        } else {
          resultEl.textContent = "--";
        }
      } finally {
        tensor.dispose();
      }
    }

    function pushHistory(label, confidence) {
      const timestamp = new Date().toLocaleTimeString();
      history.unshift({ timestamp, label, confidence });
      if (history.length > MAX_HISTORY_LENGTH) history.pop();

      // XSS対策: innerHTML ではなく createElement/textContent を使用
      historyEl.innerHTML = "";
      history.forEach((item) => {
        const div = document.createElement("div");
        div.className = "history-item";
        div.textContent = `${item.timestamp}：${item.label} (${item.confidence.toFixed(2)})`;
        historyEl.appendChild(div);
      });
    }

    // 手ランドマークを描画（接続線付き）
    function drawLandmarks(predictions) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      predictions.forEach((prediction) => {
        const { keypoints } = prediction;

        // 接続線を描画
        ctx.strokeStyle = "rgba(56, 189, 248, 0.6)";
        ctx.lineWidth = 2;
        HAND_CONNECTIONS.forEach(([startIdx, endIdx]) => {
          const start = keypoints[startIdx];
          const end = keypoints[endIdx];
          if (start && end) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
          }
        });

        // ランドマーク点を描画
        ctx.fillStyle = "rgba(56, 189, 248, 0.9)";
        keypoints.forEach((pt, idx) => {
          ctx.beginPath();
          // 手首と指先を大きく表示
          const radius = (idx === 0 || idx % 4 === 0) ? 6 : 4;
          ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // 指先に強調表示
        ctx.fillStyle = "#fbbf24";
        [4, 8, 12, 16, 20].forEach((tipIdx) => {
          const tip = keypoints[tipIdx];
          if (tip) {
            ctx.beginPath();
            ctx.arc(tip.x, tip.y, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        });
      });
    }

    // canvasサイズをvideoに合わせる（変更時のみ更新）
    function syncCanvasSize() {
      if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }
    }

    // 毎フレーム推論
    async function renderLoop() {
      // ページが非表示の場合はスキップ（パフォーマンス最適化）
      if (!isPageVisible) {
        requestAnimationFrame(renderLoop);
        return;
      }

      const predictions = await detector.estimateHands(video, {
        flipHorizontal: false,
      });

      syncCanvasSize();

      if (predictions.length > 0) {
        drawLandmarks(predictions);
        // ここでは最初の手だけを使用
        latestFeature = landmarksToFeatures(predictions[0].keypoints);
        await classifyGesture(latestFeature);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        resultEl.textContent = "--";
      }

      requestAnimationFrame(renderLoop);
    }

    // サンプル数を更新
    function updateSampleCount() {
      const counts = knn.getClassExampleCount();
      const total = Object.values(counts).reduce((sum, n) => sum + n, 0);
      const labels = Object.keys(counts);
      if (labels.length === 0) {
        sampleCountEl.textContent = "登録サンプル数: 0";
      } else {
        const details = labels.map(l => `${l}:${counts[l]}`).join(", ");
        sampleCountEl.textContent = `登録サンプル数: ${total} (${details})`;
      }
    }

    // 学習データの追加（サンプル登録）
    addSampleBtn.addEventListener("click", () => {
      if (!latestFeature) {
        statusEl.textContent = "手が検出されていません。";
        return;
      }
      const label = labelInput.value.trim();
      if (!label) {
        statusEl.textContent = "ラベルを入力してください。";
        return;
      }
      const tensor = tf.tensor(latestFeature);
      knn.addExample(tensor, label);
      tensor.dispose();
      statusEl.textContent = `ラベル「${label}」を追加しました。`;
      labelInput.value = "";
      updateSampleCount();
    });

    // KNNデータをシリアライズ
    async function serializeKnnData() {
      const dataset = knn.getClassifierDataset();
      const dataObj = {};
      for (const label of Object.keys(dataset)) {
        dataObj[label] = Array.from(await dataset[label].data());
        dataObj[label + "_shape"] = dataset[label].shape;
      }
      return dataObj;
    }

    // シリアライズしたデータからKNNを復元
    function deserializeKnnData(dataObj) {
      const dataset = {};
      const labels = Object.keys(dataObj).filter(k => !k.endsWith("_shape"));
      for (const label of labels) {
        const shape = dataObj[label + "_shape"];
        dataset[label] = tf.tensor2d(dataObj[label], shape);
      }
      knn.setClassifierDataset(dataset);
    }

    // localStorageに保存
    saveToStorageBtn.addEventListener("click", async () => {
      if (knn.getNumClasses() === 0) {
        statusEl.textContent = "保存するデータがありません。";
        return;
      }
      try {
        const data = await serializeKnnData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        statusEl.textContent = "localStorageに保存しました。";
      } catch (error) {
        console.error(error);
        statusEl.textContent = "保存に失敗しました。";
      }
    });

    // localStorageから復元
    loadFromStorageBtn.addEventListener("click", () => {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) {
          statusEl.textContent = "保存されたデータがありません。";
          return;
        }
        const data = JSON.parse(stored);
        deserializeKnnData(data);
        updateSampleCount();
        statusEl.textContent = "localStorageから復元しました。";
      } catch (error) {
        console.error(error);
        statusEl.textContent = "復元に失敗しました。";
      }
    });

    // ファイルにエクスポート
    exportFileBtn.addEventListener("click", async () => {
      if (knn.getNumClasses() === 0) {
        statusEl.textContent = "エクスポートするデータがありません。";
        return;
      }
      try {
        const data = await serializeKnnData();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `jsl-training-data-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        statusEl.textContent = "ファイルをエクスポートしました。";
      } catch (error) {
        console.error(error);
        statusEl.textContent = "エクスポートに失敗しました。";
      }
    });

    // インポートボタンクリックでファイル選択を開く
    importFileBtn.addEventListener("click", () => {
      importFileInput.click();
    });

    // ファイルからインポート
    importFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          deserializeKnnData(data);
          updateSampleCount();
          statusEl.textContent = `${file.name} をインポートしました。`;
        } catch (error) {
          console.error(error);
          statusEl.textContent = "ファイルの読み込みに失敗しました。";
        }
      };
      reader.readAsText(file);
      event.target.value = "";
    });

    // データを全削除
    clearDataBtn.addEventListener("click", () => {
      if (!confirm("すべての学習データを削除してもよろしいですか？")) {
        return;
      }
      knn.clearAllClasses();
      updateSampleCount();
      statusEl.textContent = "すべてのデータを削除しました。";
    });

    // 初期化処理
    async function init() {
      try {
        statusEl.textContent = "カメラ初期化中...";
        await setupCamera();
        statusEl.textContent = "モデル読み込み中...";
        await setupDetector();
        statusEl.textContent = "準備完了。手をカメラにかざしてください。";
        renderLoop();
      } catch (error) {
        console.error(error);
        statusEl.textContent = error.message || "初期化に失敗しました。ブラウザ権限を確認してください。";
      }
    }

    init();
  </script>
</body>
</html>
