<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dual Tab Chart Switcher</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f1923;
      color: #e0e0e0;
      min-height: 100vh;
    }

    .header {
      background: linear-gradient(135deg, #1a2a3a 0%, #0f1923 100%);
      border-bottom: 1px solid #2a3a4a;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header h1 {
      font-size: 20px;
      font-weight: 600;
      color: #f0f0f0;
    }

    .header .badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      background: #152232;
      border-bottom: 2px solid #1e3045;
    }

    .tab-btn {
      flex: 1;
      padding: 14px 24px;
      border: none;
      background: transparent;
      color: #8899aa;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      position: relative;
      transition: all 0.25s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .tab-btn:hover {
      color: #c0d0e0;
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-btn.active {
      color: #60a5fa;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: #3b82f6;
    }

    .tab-btn .lib-icon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
    }

    .tab-btn .lib-icon.echarts-icon {
      background: rgba(228, 77, 38, 0.2);
      color: #e44d26;
    }

    .tab-btn .lib-icon.d3-icon {
      background: rgba(245, 166, 35, 0.2);
      color: #f5a623;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      padding: 20px 24px;
    }

    .tab-content.active {
      display: block;
    }

    /* Chart Type Switcher */
    .chart-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .chart-controls label {
      font-size: 13px;
      color: #8899aa;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .switch-group {
      display: flex;
      background: #1a2a3a;
      border-radius: 8px;
      border: 1px solid #2a3a4a;
      overflow: hidden;
    }

    .switch-btn {
      padding: 8px 20px;
      border: none;
      background: transparent;
      color: #8899aa;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .switch-btn:not(:last-child)::after {
      content: '';
      position: absolute;
      right: 0;
      top: 25%;
      height: 50%;
      width: 1px;
      background: #2a3a4a;
    }

    .switch-btn:hover {
      color: #c0d0e0;
    }

    .switch-btn.active {
      background: #3b82f6;
      color: #fff;
    }

    .switch-btn.active::after {
      display: none;
    }

    /* Chart Container */
    .chart-wrapper {
      background: #152232;
      border: 1px solid #1e3045;
      border-radius: 12px;
      overflow: hidden;
    }

    .chart-header {
      padding: 14px 20px;
      border-bottom: 1px solid #1e3045;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .chart-header .symbol {
      font-size: 16px;
      font-weight: 600;
      color: #f0f0f0;
    }

    .chart-header .price-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .chart-header .price {
      font-size: 18px;
      font-weight: 600;
    }

    .chart-header .price.up { color: #22c55e; }
    .chart-header .price.down { color: #ef4444; }

    .chart-header .change {
      font-size: 13px;
      padding: 3px 8px;
      border-radius: 4px;
    }

    .chart-header .change.up {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
    }

    .chart-header .change.down {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .chart-area {
      height: 520px;
      position: relative;
    }

    #echarts-container {
      width: 100%;
      height: 100%;
    }

    #d3-container {
      width: 100%;
      height: 100%;
    }

    #d3-container svg {
      width: 100%;
      height: 100%;
    }

    /* D3 specific styles */
    .d3-tooltip {
      position: absolute;
      background: rgba(21, 34, 50, 0.95);
      border: 1px solid #2a3a4a;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 12px;
      color: #e0e0e0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 100;
      line-height: 1.6;
    }

    .d3-axis text {
      fill: #667788;
      font-size: 11px;
    }

    .d3-axis line,
    .d3-axis path {
      stroke: #1e3045;
    }

    .d3-grid line {
      stroke: #1a2535;
      stroke-dasharray: 2, 3;
    }

    .d3-grid path {
      stroke: none;
    }
  </style>
</head>
<body>

<div class="header">
  <h1>Chart Viewer</h1>
  <span class="badge">Demo Data</span>
</div>

<div class="tab-nav">
  <button class="tab-btn active" data-tab="echarts">
    <span class="lib-icon echarts-icon">EC</span>
    ECharts
  </button>
  <button class="tab-btn" data-tab="d3">
    <span class="lib-icon d3-icon">D3</span>
    D3.js
  </button>
</div>

<div id="tab-echarts" class="tab-content active">
  <div class="chart-controls">
    <label>Chart Type:</label>
    <div class="switch-group">
      <button class="switch-btn active" data-chart="candlestick" data-target="echarts">Candlestick</button>
      <button class="switch-btn" data-chart="line" data-target="echarts">Line</button>
    </div>
  </div>
  <div class="chart-wrapper">
    <div class="chart-header">
      <span class="symbol">DEMO/USD</span>
      <div class="price-info">
        <span class="price up" id="echarts-price">--</span>
        <span class="change up" id="echarts-change">--</span>
      </div>
    </div>
    <div class="chart-area">
      <div id="echarts-container"></div>
    </div>
  </div>
</div>

<div id="tab-d3" class="tab-content">
  <div class="chart-controls">
    <label>Chart Type:</label>
    <div class="switch-group">
      <button class="switch-btn active" data-chart="candlestick" data-target="d3">Candlestick</button>
      <button class="switch-btn" data-chart="line" data-target="d3">Line</button>
    </div>
  </div>
  <div class="chart-wrapper">
    <div class="chart-header">
      <span class="symbol">DEMO/USD</span>
      <div class="price-info">
        <span class="price up" id="d3-price">--</span>
        <span class="change up" id="d3-change">--</span>
      </div>
    </div>
    <div class="chart-area">
      <div id="d3-container"></div>
      <div class="d3-tooltip" id="d3-tooltip"></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// Demo Data Generation
// ============================================================
function generateDemoData(days) {
  const data = [];
  let price = 150;
  const baseDate = new Date('2025-01-06');

  for (let i = 0; i < days; i++) {
    const date = new Date(baseDate);
    date.setDate(baseDate.getDate() + i);
    // Skip weekends
    if (date.getDay() === 0 || date.getDay() === 6) continue;

    const volatility = 2 + Math.random() * 3;
    const trend = Math.sin(i / 15) * 0.5 + (Math.random() - 0.48) * 0.8;
    const open = price + (Math.random() - 0.5) * volatility * 0.3;
    const close = open + trend * volatility;
    const high = Math.max(open, close) + Math.random() * volatility * 0.8;
    const low = Math.min(open, close) - Math.random() * volatility * 0.8;
    const volume = Math.floor(500000 + Math.random() * 1500000);

    data.push({
      date: date.toISOString().split('T')[0],
      open: +open.toFixed(2),
      high: +high.toFixed(2),
      low: +low.toFixed(2),
      close: +close.toFixed(2),
      volume
    });

    price = close;
  }
  return data;
}

const demoData = generateDemoData(120);
const lastItem = demoData[demoData.length - 1];
const prevItem = demoData[demoData.length - 2];
const priceChange = lastItem.close - prevItem.close;
const priceChangePct = (priceChange / prevItem.close * 100).toFixed(2);
const isUp = priceChange >= 0;

// Update price displays
function updatePriceDisplay(prefix) {
  const priceEl = document.getElementById(`${prefix}-price`);
  const changeEl = document.getElementById(`${prefix}-change`);
  priceEl.textContent = `$${lastItem.close.toFixed(2)}`;
  priceEl.className = `price ${isUp ? 'up' : 'down'}`;
  changeEl.textContent = `${isUp ? '+' : ''}${priceChange.toFixed(2)} (${isUp ? '+' : ''}${priceChangePct}%)`;
  changeEl.className = `change ${isUp ? 'up' : 'down'}`;
}
updatePriceDisplay('echarts');
updatePriceDisplay('d3');

// ============================================================
// Tab Switching
// ============================================================
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');

    if (btn.dataset.tab === 'echarts') {
      echartsInstance.resize();
    } else {
      renderD3Chart(currentD3ChartType);
    }
  });
});

// ============================================================
// Chart Type Switching
// ============================================================
document.querySelectorAll('.switch-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const target = btn.dataset.target;
    const group = btn.parentElement;
    group.querySelectorAll('.switch-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    if (target === 'echarts') {
      renderEchartsChart(btn.dataset.chart);
    } else {
      currentD3ChartType = btn.dataset.chart;
      renderD3Chart(btn.dataset.chart);
    }
  });
});

// ============================================================
// ECharts Implementation
// ============================================================
const echartsInstance = echarts.init(document.getElementById('echarts-container'), 'dark');

function renderEchartsChart(type) {
  const dates = demoData.map(d => d.date);
  const upColor = '#22c55e';
  const downColor = '#ef4444';

  if (type === 'candlestick') {
    const ohlc = demoData.map(d => [d.open, d.close, d.low, d.high]);

    echartsInstance.setOption({
      backgroundColor: 'transparent',
      animation: true,
      animationDuration: 600,
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross', crossStyle: { color: '#556677' } },
        backgroundColor: 'rgba(21, 34, 50, 0.95)',
        borderColor: '#2a3a4a',
        textStyle: { color: '#e0e0e0', fontSize: 12 },
        formatter: function(params) {
          const idx = params[0].dataIndex;
          const d = demoData[idx];
          const color = d.close >= d.open ? upColor : downColor;
          return `<div style="line-height:1.8">
            <div style="font-weight:600;margin-bottom:4px">${d.date}</div>
            <div>Open: <b style="color:${color}">${d.open.toFixed(2)}</b></div>
            <div>High: <b style="color:${color}">${d.high.toFixed(2)}</b></div>
            <div>Low: <b style="color:${color}">${d.low.toFixed(2)}</b></div>
            <div>Close: <b style="color:${color}">${d.close.toFixed(2)}</b></div>
          </div>`;
        }
      },
      grid: { left: 60, right: 20, top: 20, bottom: 40 },
      xAxis: {
        type: 'category', data: dates,
        axisLine: { lineStyle: { color: '#1e3045' } },
        axisLabel: { color: '#667788', fontSize: 11 },
        splitLine: { show: true, lineStyle: { color: '#1a2535', type: 'dashed' } }
      },
      yAxis: {
        scale: true,
        axisLine: { lineStyle: { color: '#1e3045' } },
        axisLabel: { color: '#667788', fontSize: 11 },
        splitLine: { lineStyle: { color: '#1a2535', type: 'dashed' } }
      },
      dataZoom: [
        { type: 'inside', start: 0, end: 100 }
      ],
      series: [
        {
          type: 'candlestick', data: ohlc,
          itemStyle: {
            color: upColor, color0: downColor,
            borderColor: upColor, borderColor0: downColor
          }
        }
      ]
    }, true);
  } else {
    const closes = demoData.map(d => d.close);

    echartsInstance.setOption({
      backgroundColor: 'transparent',
      animation: true,
      animationDuration: 600,
      tooltip: {
        trigger: 'axis',
        backgroundColor: 'rgba(21, 34, 50, 0.95)',
        borderColor: '#2a3a4a',
        textStyle: { color: '#e0e0e0', fontSize: 12 },
        formatter: function(params) {
          const idx = params[0].dataIndex;
          const d = demoData[idx];
          return `<div style="line-height:1.8">
            <div style="font-weight:600;margin-bottom:4px">${d.date}</div>
            <div>Close: <b style="color:#60a5fa">$${d.close.toFixed(2)}</b></div>
            <div>Volume: <b>${(d.volume / 1000000).toFixed(2)}M</b></div>
          </div>`;
        }
      },
      grid: { left: 60, right: 20, top: 20, bottom: 50 },
      xAxis: {
        type: 'category', data: dates,
        axisLine: { lineStyle: { color: '#1e3045' } },
        axisLabel: { color: '#667788', fontSize: 11 },
        splitLine: { show: false }
      },
      yAxis: {
        type: 'value', scale: true,
        axisLine: { lineStyle: { color: '#1e3045' } },
        axisLabel: { color: '#667788', fontSize: 11 },
        splitLine: { lineStyle: { color: '#1a2535', type: 'dashed' } }
      },
      dataZoom: [
        { type: 'inside', start: 0, end: 100 }
      ],
      series: [{
        type: 'line', data: closes, smooth: true,
        symbol: 'none',
        lineStyle: { color: '#3b82f6', width: 2 },
        areaStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: 'rgba(59,130,246,0.25)' },
            { offset: 1, color: 'rgba(59,130,246,0.02)' }
          ])
        }
      }]
    }, true);
  }
}

renderEchartsChart('candlestick');
window.addEventListener('resize', () => {
  echartsInstance.resize();
  if (document.getElementById('tab-d3').classList.contains('active')) {
    renderD3Chart(currentD3ChartType);
  }
});

// ============================================================
// D3.js Implementation
// ============================================================
let currentD3ChartType = 'candlestick';

function renderD3Chart(type) {
  const container = document.getElementById('d3-container');
  container.innerHTML = '';

  const rect = container.getBoundingClientRect();
  const width = rect.width || 800;
  const height = rect.height || 520;
  const margin = { top: 20, right: 20, bottom: 40, left: 60 };
  const innerW = width - margin.left - margin.right;
  const innerH = height - margin.top - margin.bottom;

  const svg = d3.select('#d3-container')
    .append('svg')
    .attr('viewBox', `0 0 ${width} ${height}`)
    .attr('preserveAspectRatio', 'xMidYMid meet');

  const g = svg.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  const tooltip = document.getElementById('d3-tooltip');

  const parseDate = d3.timeParse('%Y-%m-%d');
  const parsedData = demoData.map(d => ({
    ...d,
    dateObj: parseDate(d.date)
  }));

  const xScale = d3.scaleBand()
    .domain(parsedData.map(d => d.date))
    .range([0, innerW])
    .padding(0.3);

  const xTimeScale = d3.scaleTime()
    .domain(d3.extent(parsedData, d => d.dateObj))
    .range([0, innerW]);

  if (type === 'candlestick') {
    const yMin = d3.min(parsedData, d => d.low) * 0.995;
    const yMax = d3.max(parsedData, d => d.high) * 1.005;
    const yScale = d3.scaleLinear().domain([yMin, yMax]).range([innerH, 0]);

    // Grid
    g.append('g')
      .attr('class', 'd3-grid')
      .call(d3.axisLeft(yScale).tickSize(-innerW).tickFormat(''));

    // X axis
    const tickInterval = Math.ceil(parsedData.length / 10);
    const tickValues = parsedData.filter((_, i) => i % tickInterval === 0).map(d => d.date);

    g.append('g')
      .attr('class', 'd3-axis')
      .attr('transform', `translate(0,${innerH})`)
      .call(d3.axisBottom(xScale).tickValues(tickValues))
      .selectAll('text')
      .attr('transform', 'rotate(-30)')
      .style('text-anchor', 'end');

    // Y axis
    g.append('g')
      .attr('class', 'd3-axis')
      .call(d3.axisLeft(yScale).ticks(8).tickFormat(d => `$${d.toFixed(0)}`));

    // Candles
    const candles = g.selectAll('.candle')
      .data(parsedData)
      .enter().append('g')
      .attr('class', 'candle');

    // Wicks
    candles.append('line')
      .attr('x1', d => xScale(d.date) + xScale.bandwidth() / 2)
      .attr('x2', d => xScale(d.date) + xScale.bandwidth() / 2)
      .attr('y1', innerH)
      .attr('y2', innerH)
      .attr('stroke', d => d.close >= d.open ? '#22c55e' : '#ef4444')
      .attr('stroke-width', 1);

    // Bodies
    candles.append('rect')
      .attr('x', d => xScale(d.date))
      .attr('y', d => yScale(Math.max(d.open, d.close)))
      .attr('width', xScale.bandwidth())
      .attr('height', d => Math.max(1, Math.abs(yScale(d.open) - yScale(d.close))))
      .attr('fill', d => d.close >= d.open ? '#22c55e' : '#ef4444')
      .attr('rx', 1);

    // Crosshair
    const crosshairV = g.append('line')
      .attr('stroke', '#556677').attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '4,4').style('opacity', 0);
    const crosshairH = g.append('line')
      .attr('stroke', '#556677').attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '4,4').style('opacity', 0);

    // Overlay for mouse events
    svg.append('rect')
      .attr('transform', `translate(${margin.left},${margin.top})`)
      .attr('width', innerW).attr('height', innerH)
      .attr('fill', 'transparent')
      .on('mousemove', function(event) {
        const [mx, my] = d3.pointer(event, g.node());
        const bandW = xScale.step();
        const idx = Math.floor(mx / bandW);
        if (idx < 0 || idx >= parsedData.length) return;
        const d = parsedData[idx];
        const cx = xScale(d.date) + xScale.bandwidth() / 2;

        crosshairV.attr('x1', cx).attr('x2', cx).attr('y1', 0).attr('y2', innerH).style('opacity', 1);
        crosshairH.attr('x1', 0).attr('x2', innerW).attr('y1', my).attr('y2', my).style('opacity', 1);

        const color = d.close >= d.open ? '#22c55e' : '#ef4444';
        tooltip.innerHTML = `
          <div style="font-weight:600;margin-bottom:4px">${d.date}</div>
          <div>Open: <b style="color:${color}">${d.open.toFixed(2)}</b></div>
          <div>High: <b style="color:${color}">${d.high.toFixed(2)}</b></div>
          <div>Low: <b style="color:${color}">${d.low.toFixed(2)}</b></div>
          <div>Close: <b style="color:${color}">${d.close.toFixed(2)}</b></div>
          <div>Volume: <b>${(d.volume / 1000000).toFixed(2)}M</b></div>`;
        tooltip.style.opacity = '1';

        const containerRect = container.getBoundingClientRect();
        let tx = event.clientX - containerRect.left + 16;
        let ty = event.clientY - containerRect.top - 20;
        if (tx + 180 > containerRect.width) tx = tx - 200;
        tooltip.style.left = tx + 'px';
        tooltip.style.top = ty + 'px';
      })
      .on('mouseleave', function() {
        crosshairV.style('opacity', 0);
        crosshairH.style('opacity', 0);
        tooltip.style.opacity = '0';
      });

    // Animate in
    candles.selectAll('rect')
      .attr('height', 0)
      .attr('y', innerH)
      .transition()
      .duration(600)
      .delay((d, i) => i * 3)
      .attr('y', d => yScale(Math.max(d.open, d.close)))
      .attr('height', d => Math.max(1, Math.abs(yScale(d.open) - yScale(d.close))));

    candles.selectAll('line')
      .transition()
      .duration(600)
      .delay((d, i) => i * 3)
      .attr('y1', d => yScale(d.high))
      .attr('y2', d => yScale(d.low));

  } else {
    // Line chart
    const yMin = d3.min(parsedData, d => d.close) * 0.995;
    const yMax = d3.max(parsedData, d => d.close) * 1.005;
    const yScale = d3.scaleLinear().domain([yMin, yMax]).range([innerH, 0]);

    const xLinear = d3.scaleLinear().domain([0, parsedData.length - 1]).range([0, innerW]);

    // Grid
    g.append('g')
      .attr('class', 'd3-grid')
      .call(d3.axisLeft(yScale).tickSize(-innerW).tickFormat(''));

    // X axis
    const tickInterval = Math.ceil(parsedData.length / 10);
    g.append('g')
      .attr('class', 'd3-axis')
      .attr('transform', `translate(0,${innerH})`)
      .call(d3.axisBottom(xLinear)
        .ticks(10)
        .tickFormat(i => {
          const idx = Math.round(i);
          return idx >= 0 && idx < parsedData.length ? parsedData[idx].date.slice(5) : '';
        }));

    // Y axis
    g.append('g')
      .attr('class', 'd3-axis')
      .call(d3.axisLeft(yScale).ticks(8).tickFormat(d => `$${d.toFixed(0)}`));

    // Area gradient
    const defs = svg.append('defs');
    const gradient = defs.append('linearGradient')
      .attr('id', 'd3-area-gradient')
      .attr('x1', '0%').attr('y1', '0%')
      .attr('x2', '0%').attr('y2', '100%');
    gradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgba(59,130,246,0.25)');
    gradient.append('stop').attr('offset', '100%').attr('stop-color', 'rgba(59,130,246,0.02)');

    // Area
    const area = d3.area()
      .x((d, i) => xLinear(i))
      .y0(innerH)
      .y1(d => yScale(d.close))
      .curve(d3.curveMonotoneX);

    g.append('path')
      .datum(parsedData)
      .attr('fill', 'url(#d3-area-gradient)')
      .attr('d', area);

    // Line
    const line = d3.line()
      .x((d, i) => xLinear(i))
      .y(d => yScale(d.close))
      .curve(d3.curveMonotoneX);

    const path = g.append('path')
      .datum(parsedData)
      .attr('fill', 'none')
      .attr('stroke', '#3b82f6')
      .attr('stroke-width', 2)
      .attr('d', line);

    // Animate line drawing
    const totalLength = path.node().getTotalLength();
    path.attr('stroke-dasharray', totalLength)
      .attr('stroke-dashoffset', totalLength)
      .transition()
      .duration(1200)
      .ease(d3.easeCubicOut)
      .attr('stroke-dashoffset', 0);

    // Hover dot
    const hoverDot = g.append('circle')
      .attr('r', 5)
      .attr('fill', '#3b82f6')
      .attr('stroke', '#0f1923')
      .attr('stroke-width', 2)
      .style('opacity', 0);

    // Crosshair
    const crosshairV = g.append('line')
      .attr('stroke', '#556677').attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '4,4').style('opacity', 0);
    const crosshairH = g.append('line')
      .attr('stroke', '#556677').attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '4,4').style('opacity', 0);

    // Bisector for mouse tracking
    const bisect = d3.bisector((d, x) => x - d).left;

    svg.append('rect')
      .attr('transform', `translate(${margin.left},${margin.top})`)
      .attr('width', innerW).attr('height', innerH)
      .attr('fill', 'transparent')
      .on('mousemove', function(event) {
        const [mx] = d3.pointer(event, g.node());
        const idx = Math.round(xLinear.invert(mx));
        if (idx < 0 || idx >= parsedData.length) return;
        const d = parsedData[idx];
        const cx = xLinear(idx);
        const cy = yScale(d.close);

        hoverDot.attr('cx', cx).attr('cy', cy).style('opacity', 1);
        crosshairV.attr('x1', cx).attr('x2', cx).attr('y1', 0).attr('y2', innerH).style('opacity', 1);
        crosshairH.attr('x1', 0).attr('x2', innerW).attr('y1', cy).attr('y2', cy).style('opacity', 1);

        tooltip.innerHTML = `
          <div style="font-weight:600;margin-bottom:4px">${d.date}</div>
          <div>Close: <b style="color:#60a5fa">$${d.close.toFixed(2)}</b></div>
          <div>Volume: <b>${(d.volume / 1000000).toFixed(2)}M</b></div>`;
        tooltip.style.opacity = '1';

        const containerRect = container.getBoundingClientRect();
        let tx = event.clientX - containerRect.left + 16;
        let ty = event.clientY - containerRect.top - 20;
        if (tx + 180 > containerRect.width) tx = tx - 200;
        tooltip.style.left = tx + 'px';
        tooltip.style.top = ty + 'px';
      })
      .on('mouseleave', function() {
        hoverDot.style('opacity', 0);
        crosshairV.style('opacity', 0);
        crosshairH.style('opacity', 0);
        tooltip.style.opacity = '0';
      });
  }
}
</script>

</body>
</html>
